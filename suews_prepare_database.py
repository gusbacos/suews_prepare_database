# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SUEWSPrepareDatabase
                                 A QGIS plugin
 Prepares inputdata for the SUEWS model using typology database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import  QAction, QMessageBox, QLabel, QLineEdit, QGridLayout, QVBoxLayout, QSpacerItem, QSizePolicy, QFileDialog, QComboBox
from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel, QgsVectorLayer, QgsMessageLog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .suews_prepare_database_dialog import SUEWSPrepareDatabaseDialog
import os.path
from .tabs.main_tab import MainTab
import webbrowser

#These are not needed here later
import numpy as np
import pandas as pd
import os
from osgeo import gdal, osr
from .Utilities import f90nml
from .Utilities import RoughnessCalcFunction as rg
from .Utilities.misc import saveraster
from .Utilities.db_functions import (read_DB, decide_country_or_region, fill_SUEWS_NonVeg, fill_SUEWS_NonVeg_typologies,  fill_SUEWS_Water, 
                                     fill_SUEWS_Veg, fill_SUEWS_Snow, fill_SUEWS_AnthropogenicEmission, 
                                     fill_SUEWS_profiles, blend_SUEWS_NonVeg, save_SUEWS_txt, save_snow, 
                                     save_NonVeg_types, save_SiteSelect, presave, read_morph_txt, surf_df_dict)

from .Utilities.ssParms import writeGridLayout
from shutil import copyfile, rmtree

# from .prepare_workertypo import Worker
import processing
################################################################

class SUEWSPrepareDatabase:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SUEWSPrepareDatabase_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&SUEWS Prepare (Database Typologies)')

        self.dlg = SUEWSPrepareDatabaseDialog()

        self.dlg.helpButton.clicked.connect(self.help)

        self.dlg.outputButton.clicked.connect(self.set_output_folder)
        self.dlg.runButton.clicked.connect(self.generate)

        self.outputDialog = QFileDialog()
        self.outputDialog.setFileMode(QFileDialog.Directory)
        self.outputDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.SSDialog = QFileDialog()
        self.SSDialog.setFileMode(QFileDialog.Directory)
        self.SSDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.fileDialog = QFileDialog()
        self.fileDialog.setFileMode(QFileDialog.ExistingFile)

        self.fileDialogISO = QFileDialog()
        self.fileDialogISO.setNameFilter("(*_isotropic.txt)")
        self.fileDialogISO.setFileMode(QFileDialog.ExistingFile)

        self.comboBoxCountry = None  
        self.comboBoxRegion = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None

        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        # self.wall_area = None
        self.daypop = 0
        self.typologies = 0
        self.start_DLS = 85
        self.end_DLS = 302
        self.day_since_rain = 0
        self.leaf_cycle = 0
        self.soil_moisture = 100
        self.utc = 0
        self.file_code = ''
        self.steps = 0
        # self.region = None

        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.Metfile_path = None
        # self.land_use_file_path = None
        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True

        self.vertheights ='10, 20'
        self.nlayers = 3
        self.skew = 2

        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True
        # widget.LCF_Frame.hide()
        # widget.IMP_Frame.hide()
        # widget.IMPveg_Frame.hide()

        self.comboBoxRegion = True
        self.comboBoxCountry = True
        self.comboBoxPaved = True
        self.comboBoxBuilding = True
        self.comboBoxGrass = True
        self.comboBoxEvrTree = True
        self.comboBoxDecTree = True
        
        # Read Database
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        db_dict = read_DB(db_path)
        
        # Filling comboboxes in frame for Regional Parameters
        # 'descOrigin' is a column created in read_DB to have a readable and understandable indexer shown to the user instead of using the ID
        # The lists here are the ones populating comboboxes for regional parameters
        building_list = db_dict['NonVeg']['descOrigin'].loc[db_dict['NonVeg']['Surface'] == 'Buildings']
        paved_list =    db_dict['NonVeg']['descOrigin'].loc[db_dict['NonVeg']['Surface'] == 'Paved']
        grass_list =    db_dict['Veg']['descOrigin'].loc[db_dict['Veg']['Surface'] == 'Grass']
        dec_tree_list = db_dict['Veg']['descOrigin'].loc[db_dict['Veg']['Surface'] == 'Decidous Tree']
        evr_tree_list = db_dict['Veg']['descOrigin'].loc[db_dict['Veg']['Surface'] == 'Evergreen Tree']

        self.dlg.comboBoxPaved.addItems(sorted(paved_list))
        self.dlg.comboBoxBuilding.addItems(sorted(building_list))
        self.dlg.comboBoxGrass.addItems(sorted(grass_list))
        self.dlg.comboBoxEvrTree.addItems(sorted(evr_tree_list))
        self.dlg.comboBoxDecTree.addItems(sorted(dec_tree_list))

        for cbox in [self.dlg.comboBoxPaved, self.dlg.comboBoxBuilding, self.dlg.comboBoxEvrTree, self.dlg.comboBoxDecTree, self.dlg.comboBoxGrass]:
            cbox.setCurrentIndex(-1)

        reg_list = sorted(set(list(db_dict['Region']['Region'])))
        self.dlg.comboBoxRegion.addItems(reg_list)
        self.dlg.comboBoxRegion.setCurrentIndex(-1)
        self.dlg.comboBoxCountry.addItems(sorted(set(list(db_dict['Country']['descOrigin']))))
        self.dlg.comboBoxCountry.setCurrentIndex(-1)
        
        self.dlg.comboBoxRegion.currentIndexChanged.connect(lambda: self.region_changed(db_dict))
        self.dlg.comboBoxCountry.currentIndexChanged.connect(lambda: self.country_changed(db_dict))

        self.dlg.checkBoxTypology.stateChanged.connect(lambda: self.use_typologies())
        self.dlg.checkBox_day.stateChanged.connect(lambda: self.popdaystate())

        self.dlg.layerComboManagerPolygrid.setCurrentIndex(-1)
        self.dlg.layerComboManagerPolygrid.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.layerComboManagerPolygrid.setFixedWidth(175)
        self.dlg.layerComboManagerPolyField.setFilters(QgsFieldProxyModel.LongLong)
        self.dlg.layerComboManagerPolygrid.layerChanged.connect(self.dlg.layerComboManagerPolyField.setLayer)

        # New for Typology database
        self.dlg.layerComboManagerDSM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.dlg.layerComboManagerDSM.setFixedWidth(175)
        self.dlg.layerComboManagerDSM.setCurrentIndex(-1)
        self.dlg.layerComboManagerDEM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.dlg.layerComboManagerDEM.setFixedWidth(175)
        self.dlg.layerComboManagerDEM.setCurrentIndex(-1)
        self.dlg.layerComboManagerCDSM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.dlg.layerComboManagerCDSM.setFixedWidth(175)
        self.dlg.layerComboManagerCDSM.setCurrentIndex(-1)
        self.dlg.layerComboManagerLC.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.dlg.layerComboManagerLC.setFixedWidth(175)
        self.dlg.layerComboManagerLC.setCurrentIndex(-1)

        self.dlg.layerComboManagerPolygridTypo.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.layerComboManagerPolygridTypo.setFixedWidth(175)
        self.dlg.layerComboManagerPolygridTypo.setCurrentIndex(-1)
        self.dlg.layerComboManagerPolygridTypo.layerChanged.connect(self.dlg.layerComboManagerPolygridTypofield.setLayer)

        self.dlg.pop_density.setFilters(QgsFieldProxyModel.Numeric)
        self.dlg.layerComboManagerPolygrid.layerChanged.connect(self.dlg.pop_density.setLayer)

        self.dlg.pop_density_day.setFilters(QgsFieldProxyModel.Numeric)
        self.dlg.layerComboManagerPolygrid.layerChanged.connect(self.dlg.pop_density_day.setLayer)
    
        self.dlg.pushButtonImportLCF.clicked.connect(lambda: self.set_LCFfile_path())
        self.dlg.pushButtonImportIMPVeg.clicked.connect(lambda: self.set_IMPvegfile_path())

        self.dlg.pushButtonImportIMPVeg_eve.clicked.connect(lambda: self.set_IMPvegfile_path_eve())
        self.dlg.pushButtonImportIMPVeg_dec.clicked.connect(lambda: self.set_IMPvegfile_path_dec())

        self.dlg.pushButtonImportIMPBuild.clicked.connect(lambda: self.set_IMPfile_path())
        self.dlg.pushButtonImportMet.clicked.connect(lambda: self.set_metfile_path())

        self.dlg.spinBoxStartDLS.valueChanged.connect(lambda: self.start_DLS_changed(self.dlg.spinBoxStartDLS.value()))
        self.dlg.spinBoxEndDLS.valueChanged.connect(lambda: self.end_DLS_changed(self.dlg.spinBoxEndDLS.value()))

        self.dlg.spinBoxSoilMoisture.valueChanged.connect(lambda: self.soil_moisture_changed(self.dlg.spinBoxSoilMoisture.
                                                                                           value()))
        self.dlg.comboBoxLeafCycle.currentIndexChanged.connect(lambda: self.leaf_cycle_changed(self.dlg.comboBoxLeafCycle.
                                                                                             currentIndex()))
        self.dlg.fileCodeLineEdit.textChanged.connect(lambda: self.file_code_changed(self.dlg.fileCodeLineEdit.text()))
        self.dlg.lineEditUTC.textChanged.connect(lambda: self.utc_changed(self.dlg.lineEditUTC.text()))

        #SS related GUI things
        self.dlg.pushButtonImportSS.clicked.connect(lambda: self.set_SSfolder_path())
        self.dlg.SS_comboBox.currentIndexChanged.connect(lambda: self.height_option_SS(self.dlg.SS_comboBox.currentIndex()))
        self.dlg.SS_LineEdit_constant.textChanged.connect(lambda: self.vertHeights_changed(self.dlg.SS_LineEdit_constant.text()))
        self.dlg.spinBoxLayers.valueChanged.connect(lambda: self.layersSS_changed(self.dlg.spinBoxLayers.value()))
        self.dlg.SS_checkBox_skew.stateChanged.connect(lambda: self.SS_skew())


    def tr(self, message):
        return QCoreApplication.translate('SUEWSPrepareDatabase', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/suews_prepare_database/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'SUEWS Prepare - Database Typologies'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&SUEWS Prepare - Database Typologies'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.IMPvegfile_path_dec = None
        self.IMPvegfile_path_eve = None
        self.checkBox_twovegfiles = None
        self.checkBoxTypologies = None
        self.ss_dir = None
        # self.land_use_file_path = None
        self.dlg.textOutput.clear()
        self.dlg.show()
        self.dlg.exec_()
        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        self.wall_area = None
        self.layerComboManagerDEM = None
        self.layerComboManagerDSM = None
        self.layerComboManagerLC = None
        self.layerComboManagerPolygridTypo = None
        self.comboBoxRegion = None
        self.comboBoxCountry = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None

    def help(self):
        url = "https://umep-docs.readthedocs.io/en/latest/pre-processor/Urban%20Energy%20Balance%20SUEWS%20Database%20Manager.html"
        webbrowser.open_new_tab(url)

    def set_output_folder(self):
        self.outputDialog.open()
        result = self.outputDialog.exec_()
        if result == 1:
            self.output_dir = self.outputDialog.selectedFiles()
            self.dlg.textOutput.setText(self.output_dir[0])
            self.dlg.runButton.setEnabled(1)

    def set_SSfolder_path(self):
        self.SSDialog.open()
        result = self.SSDialog.exec_()
        if result == 1:
            self.ss_dir = self.SSDialog.selectedFiles()
            self.dlg.textInputIMPDataSS.setText(self.ss_dir[0])

    def height_option_SS(self, value):
        self.heightMethod = value

    def layersSS_changed(self, value):
        self.nlayers = value

    def vertHeights_changed(self, heights):      
        self.vertheights = heights

    def SS_skew(self):
        if self.dlg.SS_checkBox_skew.isChecked():
            self.skew = 2
        else:
            self.skew = 1

    # def useconstanheight_option_SS(self, widget):
    #     if widget.SS_checkBox_constant.isChecked():
    #         self.heightMethod = 1

    def soil_moisture_changed(self, value):
        self.soil_moisture = value


    def utc_changed(self, index):
        self.utc = index


    def leaf_cycle_changed(self, index):
        self.leaf_cycle = index


    def file_code_changed(self, code):
        self.file_code = code


    def region_changed(self, db_dict):

        region_sel = self.dlg.comboBoxRegion.currentText()
        country_list = list(db_dict['Country']['descOrigin'].loc[db_dict['Country']['Region'] == region_sel])
        self.dlg.comboBoxCountry.clear()
        self.dlg.comboBoxCountry.addItems(country_list)

    def print_reg(self):
        region_sel = self.dlg.comboBoxRegion.currentText()
        return region_sel
    
   
    def print_country(self):
        country_sel = self.dlg.comboBoxCountry.currentText()
        return country_sel
    
    def country_changed(self, db_dict):

        country_sel = self.dlg.comboBoxCountry.currentText()
        reg_sel = self.dlg.comboBoxRegion.currentText()

        self.country_str = country_sel
        self.region_str = reg_sel
        
        # Update region according to country if country is chosen before region
        try:
            if  db_dict['Country'].loc[db_dict['Country']['descOrigin'] == country_sel]['Region'].item() == reg_sel:
                pass
            else:
                reg_list = [self.dlg.comboBoxRegion.itemText(i) for i in range(self.dlg.comboBoxRegion.count())]
                indexer = reg_list.index(db_dict['Country']['Region'].loc[db_dict['Country']['descOrigin'] == country_sel].item())
                self.dlg.comboBoxRegion.setCurrentIndex(indexer)
        except:
            pass

        # Function to test if a parameter is found in Country. If not, the same parameter for Region is then selected.   
        def decide_country_region(col, country_sel, reg_sel, comboBox):
            country_df = db_dict['Country'][db_dict['Country']['descOrigin'] == country_sel]
            try:
                if str(country_df[col].item()) == 'nan':
                    try:
                        reg_df = db_dict['Region'][db_dict['Region']['Region'] == reg_sel]
                        var = reg_df[col].item()
                        var_text = db_dict[surf_df_dict[col]].loc[var, 'descOrigin']
                        cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                        indexer = cbox_list.index(var_text)
                    except:
                        indexer = 0
                else:
                    var = country_df[col].item()
                    var_text = db_dict[surf_df_dict[col]].loc[var, 'descOrigin']
                    cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                    indexer = cbox_list.index(var_text)
        
                comboBox.setCurrentIndex(indexer)
            except:
                pass

        decide_country_region('Paved',country_sel, reg_sel, self.dlg.comboBoxPaved)
        decide_country_region('Buildings', country_sel, reg_sel, self.dlg.comboBoxBuilding)
        decide_country_region('Evergreen Tree',country_sel, reg_sel, self.dlg.comboBoxEvrTree)
        decide_country_region('Decidous Tree',country_sel, reg_sel, self.dlg.comboBoxDecTree)
        decide_country_region('Grass',country_sel, reg_sel, self.dlg.comboBoxGrass)


    def use_typologies(self):
        if self.dlg.checkBoxTypology.isChecked():
            self.typologies = 1
        else:
            self.typologies = 0


    def popdaystate(self):
        if self.dlg.checkBox_day.isChecked():
            self.daypop = 1
        else:
            self.daypop = 0


    def set_LCFfile_path(self):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.LCFfile_path = self.fileDialogISO.selectedFiles()
            self.dlg.textInputLCFData.setText(self.LCFfile_path[0])
        else:
            self.LCFfile_path = None
            self.dlg.textInputLCFData.setText('')


    def set_IMPfile_path(self):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.IMPfile_path = self.fileDialogISO.selectedFiles()
            self.dlg.textInputIMPData.setText(self.IMPfile_path[0])
        else:
            self.IMPfile_path = None
            self.dlg.textInputIMPData.setText('')
        # self.IMPfile_path = self.fileDialogISO.getOpenFileName()
        # self.dlg.textInputIMPData.setText(self.IMPfile_path[0])


    def set_IMPvegfile_path(self):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.IMPvegfile_path = self.fileDialogISO.selectedFiles()
            self.dlg.textInputIMPVegData.setText(self.IMPvegfile_path[0])
        else:
            self.IMPvegfile_path = None
            self.dlg.textInputIMPVegData.setText('')
        # self.IMPvegfile_path = self.fileDialogISO.getOpenFileName()
        # self.dlg.textInputIMPVegData.setText(self.IMPvegfile_path[0])


    def set_IMPvegfile_path_dec(self):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.IMPvegfile_path_dec = self.fileDialogISO.selectedFiles()
            self.dlg.textInputIMPDecData.setText(self.IMPvegfile_path_dec[0])
        else:
            self.IMPvegfile_path_dec = None
            self.dlg.textInputIMPDecData.setText('')
        # self.IMPvegfile_path_dec = self.fileDialogISO.getOpenFileName()
        # self.dlg.textInputIMPDecData.setText(self.IMPvegfile_path_dec)


    def set_IMPvegfile_path_eve(self):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.IMPvegfile_path_eve = self.fileDialogISO.selectedFiles()
            self.dlg.textInputIMPEveData.setText(self.IMPvegfile_path_eve[0])
        else:
            self.IMPvegfile_path_eve = None
            self.dlg.textInputIMPEveData.setText('')
        # self.IMPvegfile_path_dec = self.fileDialogISO.getOpenFileName()
        # self.dlg.textInputIMPEveData.setText(self.IMPvegfile_path_eve[0])


    def set_metfile_path(self):
        self.Metfile_path = self.fileDialog.getOpenFileName()
        self.dlg.textInputMetData.setText(self.Metfile_path[0])


    def start_DLS_changed(self, value):
        self.start_DLS = value


    def end_DLS_changed(self, value):
        self.end_DLS = value


    def generate(self):
        # First check that all part of the interface have been filled in correclty
        # output dir
        if self.output_dir is None:
            QMessageBox.critical(self.dlg, "Error", "No output directory selected")
            return  

        # metfile
        year = None
        year2 = None
        if self.Metfile_path is None:
            QMessageBox.critical(self.dlg, "Error", "Meteorological data file has not been provided,"
                                                " please check the main tab")
            return
        elif os.path.isfile(self.Metfile_path[0]):
            with open(self.Metfile_path[0]) as metfile:
                next(metfile)
                for line in metfile:
                    split = line.split()
                    if year == split[0]:
                        break
                    else:
                        if year2 == split[0]:
                            year = split[0]
                            break
                        elif year is None:
                            year = split[0]
                        else:
                            year2 = split[0]
        else:
            QMessageBox.critical(self.dlg, "Error", "Could not find the file containing meteorological data")
            return

        # # check polygon grid
        poly = self.dlg.layerComboManagerPolygrid.currentLayer()
        if poly is None:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        if not poly.geometryType() == 2:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        poly_field = self.dlg.layerComboManagerPolyField.currentField()
        if poly_field == '':
            QMessageBox.critical(None, "Error", "An attribute field with unique fields must be selected")
            return

        vlayer = QgsVectorLayer(poly.source(), "polygon", "ogr")

        map_units = vlayer.crs().mapUnits()
        if not map_units == 0 or map_units == 1 or map_units == 2:
            QMessageBox.critical(self.dlg, "Error", "Could not identify the map units of the polygon layer coordinate "
                                 "reference system")
            return

        # population density  from polygon grid
        if self.dlg.pop_density.currentField() == '':
            QMessageBox.critical(None, "Error", "An attribute field including night-time population density (pp/ha) must be selected")
            return

        if self.daypop == 1:
            if self.dlg.pop_density_day.currentField() == '':
                QMessageBox.critical(None, "Error", "An attribute field including working population density (pp/ha) must be selected")
                return            

        # Leaf cycle
        if self.leaf_cycle == 0:
            QMessageBox.critical(self.dlg, "Error", "No leaf cycle period has been selected")
            return
        else:
            if not (self.leaf_cycle == 1 or self.leaf_cycle == 5):
                QMessageBox.critical(self.dlg,"Warning", "A transition period between Winter and Summer has been "
                                     "choosen. Preferably start the model run during Winter or Summer.")

        if self.LCF_from_file:
            if self.LCFfile_path is None:
                QMessageBox.critical(None, "Error", "Land cover fractions file has not been provided,"
                                                        " please check the main tab")
                return
            if not os.path.isfile(self.LCFfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing land cover fractions")
                return

        # Morphometric and land cover files
        if self.IMP_from_file:
            if self.IMPfile_path is None:
                QMessageBox.critical(None, "Error", "Building morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing building morphology")
                return

        if self.IMPveg_from_file:
            if self.IMPvegfile_path is None:
                QMessageBox.critical(None, "Error", "Vegetation morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPvegfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing vegetation morphology")
                return

        if self.file_code == '':
            QMessageBox.critical(None, "Error", "Specify a file code prefix")
            return

        # vlayer.source()

        # # DSM layer for aggegation
        dsmlayer = self.dlg.layerComboManagerDSM.currentLayer()
        if dsmlayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid ground and building DSM is selected")
            return

        demlayer = self.dlg.layerComboManagerDEM.currentLayer()
        if demlayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid DEM selected")
            return
        
        cdsmlayer = self.dlg.layerComboManagerCDSM.currentLayer()
        if cdsmlayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid vegetation DSM (CDSM) selected")
            return

        # # Land cover layer for aggegation
        lclayer = self.dlg.layerComboManagerLC.currentLayer()
        if lclayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid land cover grid is selected")
            return   

        polyTypolayer = self.dlg.layerComboManagerPolygridTypo.currentLayer()
        if self.typologies == 1 and polyTypolayer is None:
            QMessageBox.critical(None, "Error", "No valid Urban typology polygon layer is selected")
            return     
        
        # Region check
        if self.dlg.comboBoxRegion.currentIndex() == -1:
            QMessageBox.critical(self.dlg, "Error", "No region has been selected")
            return
        
        typologyFieldName = self.dlg.layerComboManagerPolygridTypofield.currentText()

        # TODO 
        # self.dlg.progressBar.setMaximum(vlayer.featureCount())     

        #Here worker loop starts. We make function. Then it is easier to put in worker latery

        # wait here. How shall we do????

        # QMessageBox.critical(None, "OK", "Frrk")
        # return  



        self.generateSiteSelect(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
                         self.IMP_from_file, self.IMPfile_path, self.IMP_z0, self.IMP_zd, self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, 
                         self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, self.plugin_dir, map_units, self.output_dir, self.file_code,
                         self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop,
                         polyTypolayer, typologyFieldName, dsmlayer, demlayer, lclayer, self.region_str, self.country_str, self.typologies,
                         self.heightMethod, self.vertheights, self.nlayers, self.skew, self.ss_dir)

        # self.startWorker(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
        #                  self.LCF_Paved, self.LCF_Buildings, self.LCF_Evergreen, self.LCF_Decidious, self.LCF_Grass, self.LCF_Baresoil,
        #                  self.LCF_Water, self.IMP_from_file, self.IMPfile_path, self.IMP_mean_height, self.IMP_z0, self.IMP_zd,
        #                  self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, self.IMPveg_mean_height_eve,
        #                  self.IMPveg_mean_height_dec, self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, 
        #                  self.plugin_dir, map_units,
        #                  self.output_dir, self.day_since_rain, self.leaf_cycle, self.soil_moisture, self.file_code,
        #                  self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop)

    #TODO: check so that utc is written correctly
    #TODO: 
    def generateSiteSelect(self, vlayer, poly_field, Metfile_path, start_DLS, end_DLS, LCF_from_file, LCFfile_path,
                         IMP_from_file, IMPfile_path, IMP_z0, IMP_zd, IMP_fai, IMPveg_from_file, IMPvegfile_path, 
                         IMPveg_fai_eve, IMPveg_fai_dec, pop_density, plugin_dir, map_units, output_dir, file_code,
                         utc, checkBox_twovegfiles, IMPvegfile_path_dec, IMPvegfile_path_eve, pop_density_day, daypop,
                         polyTypolayer, typologyFieldName, dsmlayer, demlayer, lclayer, region_str, country_str, checkBoxTypologies,
                         heightMethod, vertheights, nlayers, skew, ss_dir):

        save_txt_folder = output_dir[0]+ '/'
        temp_folder = plugin_dir + '/agg'
        build_raster_out = temp_folder + '/buildings.tif'

        ss_dict = {}            # SiteSelect Dict. This is the final dict where all parameters for each grid are found. 
        veg_dict = {}           # dict for populating and sorting Veg parameter
        nonVeg_dict = {}        # dict for populating and sorting NonVeg parameter
        blend_dict= {}          # dict for aggregating and creating new codes if needed when using typologies
        dict_out = {}           # Unknown TODO Describe
        country_conv_dict = {}  # Dict for getting selected Country parameters
        reg_conv_dict = {}      # Dict for getting selected Regional parameters
        parameter_dict = {}        # Unkown TODO Describe

        # Dict for setting correct codes from surfaces
        surf_to_code_dict = {
            'Paved' : 'Code_Paved',
            'Buildings' : 'Code_Bldgs',
            'Bare Soil': 'Code_Bsoil',
            'Grass' : 'Code_Grass',
            'Evergreen Tree' : 'Code_EveTr',
            'Decidous Tree' :  'Code_DecTr',
            'Water' : 'Code_Water' 
            } 
    
        # Read DB
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        db_dict = read_DB(db_path)

        type_id_dict = {}   # Dict used in aggregation for assigning correct Typology

        for row in db_dict['NonVeg'].loc[db_dict['NonVeg']['Surface'] == 'Buildings'].index:
            type_id_dict[db_dict['NonVeg'].loc[row, 'descOrigin']] = row 
        
        # Get ID Values from Region and Country that will be needed for assinging correct parameters later on
        for index in list(db_dict['Country'].index):
            country_conv_dict[index] = db_dict['Country'].loc[index, 'Country'] + ', ' + db_dict['Country'].loc[index, 'City']
        country_conv_dict_inv = {v: k for k, v in country_conv_dict.items()}

        for index in list(db_dict['Region'].index):
            reg_conv_dict[index] = db_dict['Region'].loc[index, 'Region']
        country_sel = db_dict['Country'].loc[[country_conv_dict_inv[country_str]]]
        
        # Drop irrelevant (for what to come) columns
        column_list = db_dict['Country'].drop(columns = ['Region','Country','City']).columns
        
        # Set parameters from regional or country level and populate that into the parameter_dict
        for column in column_list:
            parameter_dict[column] = decide_country_or_region(column, country_sel, db_dict['Region'])

        # set correct values and write txt.files based on the parameters found at country/regional level 
        AnEm_dict = fill_SUEWS_AnthropogenicEmission(parameter_dict['AnthropogenicCode'], parameter_dict, db_dict) # FIX!
        snow_dict = fill_SUEWS_Snow(parameter_dict['SnowCode'], db_dict)
        water_dict = fill_SUEWS_Water(parameter_dict['Water'], db_dict, parameter_dict)

        # TODO Fill NonVegPavedBsoil

        cond_dict = db_dict['Conductance'].loc[parameter_dict['Conductance']].to_dict()
        cond_dict['Code'] = parameter_dict['Conductance']

        if LCF_from_file:
            LCF_dict = read_morph_txt(LCFfile_path[0])

        if IMP_from_file:
            IMP_dict = read_morph_txt(IMPfile_path[0])

        if IMPveg_from_file:
            IMPveg_dict = read_morph_txt(IMPvegfile_path[0])
        
        # IF Using Typologies then aggregation is needed. Otherwise no aggregation will be done
        if checkBoxTypologies == 1:
        # DEM & DSM to array

            gdal.AllRegister()
            provider = demlayer.dataProvider()
            filePath_dem = str(provider.dataSourceUri())
            dem = gdal.Open(filePath_dem)
            dem_arr = dem.ReadAsArray().astype(float)

            provider = dsmlayer.dataProvider()
            filePath_dsm = str(provider.dataSourceUri())
            dsm = gdal.Open(filePath_dsm)
            dsm_arr = dsm.ReadAsArray().astype(float)
    
            pixelSize = dsm.GetGeoTransform()[1]    

            # If need to use CDSM
            # provider = dsmlayer.dataProvider()
            # filePath_cdsm = str(provider.dataSourceUri())
            # dataSet = gdal.Open(filePath_cdsm)
            # cdsm_arr = dataSet.ReadAsArray().astype(float)
            
            provider = lclayer.dataProvider()
            filePath_lc = str(provider.dataSourceUri())
        
            # If need to have Lc as Array
            # dataSet = gdal.Open(filePath_lc)
            # lc_arr = dataSet.ReadAsArray().astype(float) # lc not needed to be array at the moment. 

            # # Clean temp folder
            try:
                rmtree(temp_folder)
            except OSError as e:
                print ("Error: %s - %s." % (e.filename, e.strerror))

            os.mkdir(temp_folder)
            
            geodata_output = {} # Dict for storing the output of the QGIS geodata processes

            # TODO Clip rasters to speed up process

            # Grid classified shp-file containing SUEWS typologies
            parin = { 'INPUT' : vlayer,
                'INPUT_FIELDS' : [], 
                'OUTPUT' : temp_folder + '/urbantypelayer.shp', # 'TEMPORARY_OUTPUT',#urbantypelayer,
                'OVERLAY' : polyTypolayer, 
                'OVERLAY_FIELDS' : [], 
                'OVERLAY_FIELDS_PREFIX' : '' }
            geodata_output['gridded_shp'] = processing.run('native:intersection', parin)

            # Dissolve on GridID and Typology. 
            parin = {
                'INPUT':geodata_output['gridded_shp']['OUTPUT'], 
                'FIELD':['ID',typologyFieldName],
                'SEPARATE_DISJOINT':False,
                'OUTPUT': temp_folder + '/urbantypelayer_diss.shp'}
            
            geodata_output['gridded_shp_diss'] =processing.run("native:dissolve", parin)

            # isolate buildings in dsm to be able to calculate mean height
            build_arr = dsm_arr-dem_arr
            build_arr[np.where(build_arr < 1.0)] = np.nan
            saveraster(gdal.Open(filePath_dsm), build_raster_out, build_arr)

            ################# Start calculating volumetric fractions ###########################

            # This dictionary retrieve the Code for selected typologies. The Reclassifier uses String values, but later on we need codes in Int
            # str_to_code_dict = db_dict['Types']['descOrigin'].to_dict() # TODO Change this to below when we have removed typology level buildings
            str_to_code_dict = db_dict['NonVeg']['descOrigin'].to_dict() # TODO Use this later on instead
            str_to_code_dict = {v: k for k, v in str_to_code_dict.items()}  # This is just the same dictionary but inverted

            maxheight = int(np.nanmax(build_arr)) # Maxheight as Int used in the loop for calculating building volume
            build_arr_chunk_out = temp_folder + '/build_volume.tif'

            # Calculate building volume for each height
            idx = 1


            for z_height in range(10, maxheight, 10): # TODO change to something else with heights 
            # # for z_height in range(1, maxheight): # this could work but takes bit more time calculate volume each meter (z) 
            #     min_height = z_height -1
            #     max_height = z_height

                if idx == 1:
                    min_height = 1
                else:
                    min_height = z_height - max_height

                max_height = z_height
                z_difference = max_height - min_height # get height to calculate volume on

                # All cells that are lower than maxheight is set to nan
                build_arr_chunk = np.where((build_arr < max_height) , np.nan,build_arr)  

                # all cells that are not nan are given the number for pixelsize of raster
                build_arr_chunk = np.where((build_arr_chunk >1  ) , pixelSize, build_arr_chunk) 

                # Save to raster to be able to use zonal stats
                saveraster(gdal.Open(filePath_dsm), build_arr_chunk_out , build_arr_chunk)  

                # Zonal statstics: Count pixels within each grid/typology
                parin = {
                    'INPUT': geodata_output['gridded_shp_diss']['OUTPUT'],
                    'INPUT_RASTER':build_arr_chunk_out,
                    'RASTER_BAND':1,
                    'COLUMN_PREFIX':'pixel_',
                    'STATISTICS':[0], # Count
                    'OUTPUT':'TEMPORARY_OUTPUT'}
                
                output_name = 'buildings_zheight' # or perhaps something like this? + str(int(min_height)) + '_' + str(int(max_height)). now, it overwrites
                geodata_output[output_name] = processing.run("native:zonalstatisticsfb", parin) 
                
                # Read zonal_stats vectorlayer and read as a dataframe for easier handling the attribute table
                z_stats_vlayer = geodata_output[output_name]['OUTPUT']

                cols = [f.name() for f in z_stats_vlayer.fields()] 
                datagen = ([f[col] for col in cols] for f in z_stats_vlayer.getFeatures())

                df = pd.DataFrame.from_records(data=datagen, columns=cols)#[['ID', typologyFieldName,'pixel_count']] # ID = grid_id, inewfield = typology,       
                df = df.set_index('ID')  # Set ID as index in df to be able to slice in df 

                # volume (pixel_count / pixelsize to get meters ) * z_difference
                df['volume'] = (df['pixel_count'] / pixelSize)  * z_difference

                # if statement to create df_merge, the df where the volume is added for each height 
                if idx == 1:
                    df_merge = df.copy()
                    idx = idx +1

                # if not first height, add volume for each height
                else:
                    df_merge['volume'] = df_merge['volume'] + df['volume']

            ############## Calculate fractions based on volume ###############

            # Create empty column to fill in df_merge with fractions
            df_merge['fraction'] = 0

            # Replace String identifier with Code as used in Database
            df_merge['typology'] = df_merge[typologyFieldName]
            df_merge['typology'] = df_merge['typology'].replace(str_to_code_dict) 

            # grid_dict holds information on volume for typologies in each grid

            #############################################################################################
            # Now all fractions is calculated. Here the aggregation and filling of SUEWS_.txt files begin
            # vlayer == grid layer
            grid_dict = {}      # Dict that holds information on typologies and fractions

            for feature in vlayer.getFeatures(): 
                id = int(feature.attribute(poly_field))
                print('Processing ID for aggregation: ' + str(id))
                
                # Fraction = pixel_count(volume) in each typology and grid / sum of pixel_count(volume) in each grid 
                df_merge.loc[id,'fraction'] = df_merge.loc[id, 'volume'] /df_merge.loc[id, 'volume'].sum()

                # Create new key for each grid_id
                grid_dict[id] =   {}
                nonVeg_dict[id] = {}

                # iterate over all typologies in grid_id and populate dictionary
                for row in df_merge.loc[[id]].iterrows():
                    typology = row[1]['typology']
                    fraction = row[1]['fraction']
                    grid_dict[id][typology] = fraction # populate

                typology_list = list(grid_dict[id].keys())#
                # typology_list = set(list(db_dict['Types'].loc[list(grid_dict[id].keys()), 'Buildings'])) # TODO Change when removed layer of Types
                
                # Check if aggregation is needed
                if len(typology_list) > 1:
                    nonVeg_dict[id]['Buildings'] = blend_SUEWS_NonVeg(grid_dict, db_dict, id, parameter_dict)
                else:
                # f only one typology exists, no need to aggregate/combine/blend
                    nonVeg_dict[id]['Buildings'] = fill_SUEWS_NonVeg_typologies(typology_list[0], db_dict, parameter_dict)

                nonVeg_dict[id]['Paved']    = fill_SUEWS_NonVeg_typologies(parameter_dict['Paved'], db_dict, parameter_dict)
                nonVeg_dict[id]['Bare Soil'] = fill_SUEWS_NonVeg_typologies(parameter_dict['Bare Soil'], db_dict, parameter_dict)
            
            # write to SUEWS_NonVeg
            save_NonVeg_types(nonVeg_dict, save_txt_folder, db_dict)

        # If not using Typologies
        else:
            # prepare the parameters collected to for writing SUEWS_NonVeg
            nonVeg_dict = fill_SUEWS_NonVeg(db_dict, parameter_dict)
            # write to SUEWS_NonVeg
            save_SUEWS_txt(pd.DataFrame.from_dict(nonVeg_dict, orient='index').set_index('Code'), 'SUEWS_NonVeg.txt', save_txt_folder, db_dict)      

        # Write SUEWS.txt files SUEWS_veg, SUEWS_AnthropogenicEmission, SUEWS_Water and SUEWS_Conductance
        veg_dict = fill_SUEWS_Veg(db_dict, parameter_dict)

        save_SUEWS_txt(pd.DataFrame.from_dict(veg_dict, orient='index').set_index('Code'), 'SUEWS_Veg.txt', save_txt_folder, db_dict)
        save_SUEWS_txt(pd.DataFrame.from_dict(AnEm_dict, orient = 'index').T.set_index('Code'), 'SUEWS_AnthropogenicEmission.txt', save_txt_folder, db_dict)
        save_SUEWS_txt(pd.DataFrame.from_dict(water_dict, orient = 'index').set_index('Code'), 'SUEWS_Water.txt', save_txt_folder, db_dict)
        save_SUEWS_txt(pd.DataFrame.from_dict(cond_dict, orient = 'index').T.set_index('Code'), 'SUEWS_Conductance.txt', save_txt_folder, db_dict)
    
        save_SUEWS_txt(db_dict['Irrigation'].loc[[parameter_dict['IrrigationCode']]].rename_axis('Code'), 'SUEWS_Irrigation.txt', save_txt_folder, db_dict)
        save_SUEWS_txt(db_dict['Soil'].loc[[parameter_dict['SoilTypeCode']]].rename_axis('Code'), 'SUEWS_Soil.txt', save_txt_folder, db_dict)

        # write SUEWS_Snow
        save_snow(snow_dict, save_txt_folder, db_dict)

        # Save Profiles
        profiles = ['TrafficRate_WD','TrafficRate_WE', 'EnergyUseProfWD','EnergyUseProfWE','ActivityProfWD','ActivityProfWE','PopProfWD','PopProfWE', 'SnowClearingProfWD', 'SnowClearingProfWE','WaterUseProfManuWD','WaterUseProfManuWE','WaterUseProfAutoWD','WaterUseProfAutoWE']        
        profiles_list = []
        for i in profiles:
            profiles_list.append(parameter_dict[i])
            profiles_list = list(set(profiles_list))

        fill_SUEWS_profiles(profiles_list, save_txt_folder, db_dict['Profiles']) 

        OHM_list = []
        BIOCO2_list = []
        

        # Iterate through all parameter dicts to ensure that all used ESTM, OHM and Biogen codes are written into the SUEWS.txt files
        for dict_sel, dict_name in zip([nonVeg_dict, veg_dict, snow_dict, water_dict ],['NonVeg', 'Veg', 'Snow', 'Water']):
            
            for feat_id in list(dict_sel.keys()):
                    # try:
                    #     ESTM_list.append(dict_sel[i]['ESTMCode'])
                    # except:
                    #     pass
                if dict_name == 'Snow' or dict_name == 'Water':
                    try:
                        OHM_list.append(dict_sel[feat_id]['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel[feat_id]['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel[feat_id]['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel[feat_id]['OHMCode_WinterDry'])
                    except:
                        OHM_list.append(dict_sel['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel['OHMCode_WinterDry'])
                    try:
                        BIOCO2_list.append(dict_sel[feat_id]['BiogenCO2Code'])
                    except:
                        pass
                else: 
                    if dict_name == 'NonVeg':
                        surface_list = ['Paved', 'Buildings','Bare Soil']
                        for surf in surface_list:
                            # ESTM_list.append(dict_sel[feat_id][surf]['ESTMCode'])
                            try:
                                OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerWet'])
                                OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerDry'])
                                OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])
                                OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])
                            except:
                                print(feat_id)
                                print(surf)
                                print(dict_sel[feat_id])
                    else:
                        surface_list = ['Grass', 'Evergreen Tree','Decidous Tree']
                        for surf in surface_list:
                        # ESTM_list.append(dict_sel[feat_id][surf]['ESTMCode'])
                            OHM_list.append(dict_sel[surf]['OHMCode_SummerWet'])
                            OHM_list.append(dict_sel[surf]['OHMCode_SummerDry'])
                            OHM_list.append(dict_sel[surf]['OHMCode_WinterWet'])
                            OHM_list.append(dict_sel[surf]['OHMCode_WinterWet'])

    
        
        # Remove duplicates
        # ESTM_list = list(set(ESTM_list))
        OHM_list = list(set(OHM_list))
        BIOCO2_list = list(set(BIOCO2_list))

        # save SUEWS_ESTMCoefficients.txt, SUEWS_OHMCoefficients.txt and SUEWS_BiogenCO2.txt
        # presave(db_dict['ESTM'], 'ESTMCoefficients', ESTM_list, save_txt_folder)
        presave(db_dict['OHM'], 'OHMCoefficients', OHM_list, save_txt_folder, db_dict)
        presave(db_dict['Biogen CO2'], 'BiogenCO2', BIOCO2_list, save_txt_folder, db_dict)

        # ################################################################################################################################
        #                                               Writing SiteSelect and GridLayoutXXX.nml      
        # ################################################################################################################################

        ind = 1
        # Loop Start for each Grid
        for feature in vlayer.getFeatures():
            # 
            # NOT SURE WHAT THIS IS BELOW??
            #  
            # if self.killed is True:
            #     break
            # new_line = [None] * (len(self.nbr_header) - 3)
            # print_line = True
            # feat_id = int(feature.attribute(self.poly_field))
            # code = "Grid"
            # index = self.find_index(code)
            # new_line[index] = str(feat_id)
            # print('Processing ID: ' + str(feat_id))
            # # if killed is True:
            # #     break
            # # new_line = [None] * (len(nbr_header) - 3)
            # print_line = True
            
            feat_id = int(feature.attribute(poly_field))
    
            print('Processing ID: ' + str(feat_id))
            year = None     # Not sure what this is, but it works
            year2 = None    # Not surre what this is, but it works
            
            ss_dict[feat_id] = {}  # Set new key for grid in ss_dicts

            # Write GridLayoutXXX.nml
            # print(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt')
            ssVect = np.loadtxt(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt', skiprows = 1) #vertical info from IMP calc
            writeGridLayout(ssVect, heightMethod, vertheights, nlayers, skew, file_code, str(feat_id), save_txt_folder)
        

            if Metfile_path is None:
                QMessageBox.critical(None, "Error", "Meteorological data file has not been provided,"
                                                    " please check the main tab")
                return
            elif os.path.isfile(Metfile_path[0]):
                with open(Metfile_path[0]) as file:
                    next(file)
                    for line in file:
                        split = line.split()
                        if year == split[0]:
                            break
                        else:
                            if year2 == split[0]:
                                year = split[0]
                                break
                            elif year is None:
                                year = split[0]
                            else:
                                year2 = split[0]

                # figure out the time res of input file
                if ind == 1:
                    met_old = np.genfromtxt(Metfile_path[0], skip_header=1, skip_footer=2)
                    id = met_old[:, 1]
                    it = met_old[:, 2]
                    imin = met_old[:, 3]
                    dectime0 = id[0] + it[0] / 24 + imin[0] / (60 * 24)
                    dectime1 = id[1] + it[1] / 24 + imin[1] / (60 * 24)
                    res = int(np.round((dectime1 - dectime0) * (60 * 24)))
                    ind = 999

            else:
                QMessageBox.critical(None, "Error",
                                        "Could not find the file containing meteorological data")
                return

            old_cs = osr.SpatialReference()
            vlayer_ref = vlayer.crs().toWkt()
            old_cs.ImportFromWkt(vlayer_ref)

            wgs84_wkt = """
            GEOGCS["WGS 84",
                DATUM["WGS_1984",
                    SPHEROID["WGS 84",6378137,298.257223563,
                        AUTHORITY["EPSG","7030"]],
                    AUTHORITY["EPSG","6326"]],
                PRIMEM["Greenwich",0,
                    AUTHORITY["EPSG","8901"]],
                UNIT["degree",0.01745329251994328,
                    AUTHORITY["EPSG","9122"]],
                AUTHORITY["EPSG","4326"]]"""

            new_cs = osr.SpatialReference()
            new_cs.ImportFromWkt(wgs84_wkt)

            transform = osr.CoordinateTransformation(old_cs, new_cs)

            centroid = feature.geometry().centroid().asPoint()
            area = feature.geometry().area()

            if map_units == 0:
                hectare = area * 0.0001 # meter

            elif map_units == 1:
                hectare = area / 107640. # square foot

            else:
                hectare = area
            # gdalver == GDAL-version
            gdalver = float(gdal.__version__[0])
            lonlat = transform.TransformPoint(centroid.x(), centroid.y())
            
            altitude = 0    # TODO Is this not set?
            day = 1         # 
            hour = 0        #
            minute = 0      # 

            if LCF_from_file:
                LCF_paved     = LCF_dict[feat_id]['Paved']
                LCF_buildings = LCF_dict[feat_id]['Buildings']
                LCF_evergreen = LCF_dict[feat_id]['EvergreenTrees']
                LCF_decidious = LCF_dict[feat_id]['DecidiousTrees']
                LCF_grass     = LCF_dict[feat_id]['Grass']
                LCF_baresoil  = LCF_dict[feat_id]['Baresoil']
                LCF_water     = LCF_dict[feat_id]['Water']
            
            # else:
            #     LCF_paved = feature.attribute(LCF_paved.getFieldName())
            #     LCF_buildings = feature.attribute(LCF_buildings.getFieldName())
            #     LCF_evergreen = feature.attribute(LCF_evergreen.getFieldName())
            #     LCF_decidious = feature.attribute(LCF_decidious.getFieldName())
            #     LCF_grass = feature.attribute(LCF_grass.getFieldName())
            #     LCF_baresoil = feature.attribute(LCF_baresoil.getFieldName())
            #     LCF_water = feature.attribute(LCF_water.getFieldName())    
            # 
            irrFr_EveTr = 0
            irrFr_DecTr = 0
            irrFr_Grass = 0
            IrrFr_Bldgs = 0
            IrrFr_Paved = 0
            IrrFr_Water = 0
            IrrFr_BSoil = 0

            TrafficRate_WD = 0.01 ## Already in dict
            TrafficRate_WE = 0.01 ## Already in dict

            QF0_BEU_WD = 0.88 ## Already in dict
            QF0_BEU_WE = 0.88 ## Already in dict
           
            if IMP_from_file:
                IMP_heights_mean = IMP_dict[feat_id]['zH']
                IMP_z0 = IMP_dict[feat_id]['z0']
                IMP_zd = IMP_dict[feat_id]['zd']
                IMP_fai = IMP_dict[feat_id]['fai']
                IMP_max = IMP_dict[feat_id]['zHmax']
                IMP_sd = IMP_dict[feat_id]['zHstd']
                IMP_wai = IMP_dict[feat_id]['wai']
            # else:
            #     IMP_heights_mean = feature.attribute(IMP_mean_height.getFieldName())
            #     IMP_z0 = feature.attribute(IMP_z0.getFieldName())
            #     IMP_zd = feature.attribute(IMP_zd.getFieldName())
            #     IMP_fai = feature.attribute(IMP_fai.getFieldName())
            #     IMP_wai = feature.attribute(IMP_wai.getFieldName())

            if IMPveg_from_file:
                IMPveg_heights_mean_eve = IMPveg_dict[feat_id]['zH']
                IMPveg_heights_mean_dec = IMPveg_dict[feat_id]['zH']
                IMPveg_fai_eve = IMPveg_dict[feat_id]['fai']
                IMPveg_fai_dec = IMPveg_dict[feat_id]['fai']
                IMPveg_max_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_sd_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_max_dec = IMPveg_dict[feat_id]['zHstd']
                IMPveg_sd_dec = IMPveg_dict[feat_id]['zHstd']
            # else:
            #     IMPveg_heights_mean_eve = feature.attribute(IMPveg_mean_height_eve.getFieldName())
            #     IMPveg_heights_mean_dec = feature.attribute(IMPveg_mean_height_dec.getFieldName())
            #     IMPveg_fai_eve = feature.attribute(IMPveg_fai_eve.getFieldName())
            #     IMPveg_fai_dec = feature.attribute(IMPveg_fai_dec.getFieldName())

            # New calcualtion of rouhgness params v2017 (Kent et al. 2017b)
            # Evergreen not yet included in the calculations
            LCF_de = float(LCF_decidious)
            LCF_ev = float(LCF_evergreen)
            LCF_bu = float(LCF_buildings)
            LCF_tr = LCF_de + LCF_ev # temporary fix while ev and de is not separated, issue 155
            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                zH = 0
                zMAx = 0
            else:
                zH = (float(IMP_heights_mean) * LCF_bu + float(IMPveg_heights_mean_eve) * LCF_ev + float(IMPveg_heights_mean_dec) * LCF_de) / (LCF_bu + LCF_ev + LCF_de)                    
                zMax = max(float(IMPveg_max_dec),float(IMP_max))

            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                sdComb = 0
                IMP_z0 = 0
                IMP_zd = 0
                # sdTree = np.sqrt((IMPveg_sd_eve ^ 2 / LCF_evergreen * area) + (IMPveg_sd_dec ^ 2 / LCF_decidious * area))  # not used yet
            elif (LCF_tr == 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMP_sd) ** 2. / (LCF_bu * float(area)))  # Fix (fLCF_bu) issue #162
            elif (LCF_tr != 0 and LCF_bu == 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)))
            elif (LCF_tr != 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)) + float(IMP_sd) ** 2. / (LCF_bu * float(area)))

            pai = LCF_bu + LCF_ev + LCF_de
            
            # paiall = (planareaB + planareaV) / AT
            porosity = 0.2  # This should change with season. Net, set for Summer
            Pv = ((-1.251 * porosity ** 2) / 1.2) + ((0.489 * porosity) / 1.2) + (0.803 / 1.2)  # factor accounting for porosity to correct total fai in roughness calc Kent et al. 2017b
            # faiall_rgh = (frontalareaB + (Pv * frontalareaV)) / (AT / (1 / scale))  # frontal area used in roughness calculation Kent et al. 2017b
            fai = Pv * (float(IMPveg_fai_eve) + float(IMPveg_fai_dec)) + float(IMP_fai)
            if (fai == 0. and pai == 1.):
                IMP_z0 = 0.
                IMP_zd = zH
            elif (fai == 0. and pai < 1.):
                IMP_z0 = 0.
                IMP_zd = 0.
            else:
                IMP_zd, IMP_z0 = rg.RoughnessCalc("Kan", zH, fai, pai, zMax, sdComb)

            # clean up and give open country values if non-existant
            if np.isnan(IMP_z0) or IMP_z0 < 0.03:
                IMP_z0 = 0.03
            if np.isnan(IMP_zd) or IMP_zd < 0.2:
                IMP_zd = 0.2

            # # new for z (2017)
            try:
                z = ((float(IMP_heights_mean) * float(LCF_buildings) + float(IMPveg_heights_mean_eve) * float(LCF_evergreen) +
                    float(IMPveg_heights_mean_dec) * float(LCF_decidious)) / (float(LCF_buildings) + float(LCF_evergreen) + float(LCF_decidious))) * 3
            except:
                z = 10.
            if z < 10.:
                z = 10.

            if pop_density is not None:
                pop_density_night = feature.attribute(pop_density.currentField())
            else:
                pop_density_night = -999

            if daypop == 1:
                pop_density_day = feature.attribute(pop_density_day.currentField())
            else:
                pop_density_day = pop_density_night


            # TODO Not sure on these settings
            LUMPS_drate = 0.25
            LUMPS_Cover = 1
            LUMPS_MaxRes = 10
            NARP_Trans = 1

            flow_change = 0
            RunoffToWater = 0.1
            PipeCap = 100
            GridConn1of8 = 0
            Fraction1of8 = 0
            GridConn2of8 = 0
            Fraction2of8 = 0
            GridConn3of8 = 0
            Fraction3of8 = 0
            GridConn4of8 = 0
            Fraction4of8 = 0
            GridConn5of8 = 0
            Fraction5of8 = 0
            GridConn6of8 = 0
            Fraction6of8 = 0
            GridConn7of8 = 0
            Fraction7of8 = 0
            GridConn8of8 = 0
            Fraction8of8 = 0

            # WithinGrid not solved yet.
            WhitinGridPav = 661
            WhitinGridBldg = 662
            WhitinGridEve = 663
            WhitinGridDec = 664
            WhitinGridGrass = 665
            WhitinGridUnmanBsoil = 666
            WhitinGridWaterCode = 667

            # TODO Remove, for now, just keep to make SUEWS work
            Fr_ESTMClass_Paved1 = 0.  ## Already in dict
            Fr_ESTMClass_Paved2 = 1.  ## Already in dict
            Fr_ESTMClass_Paved3 = 0.  ## Already in dict
            Code_ESTMClass_Paved1 = 99999  ## Already in dict
            Code_ESTMClass_Paved2 = 807  ## Already in dict
            Code_ESTMClass_Paved3 = 99999  ## Already in dict
            Fr_ESTMClass_Bldgs1 = 1.0  ## Already in dict
            Fr_ESTMClass_Bldgs2 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs3 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs4 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs5 = 0.  ## Already in dict
            Code_ESTMClass_Bldgs1 = 801  ## Already in dict
            Code_ESTMClass_Bldgs2 = 99999  ## Already in dict
            Code_ESTMClass_Bldgs3 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs4 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs5 = 99999 ## Already in dict

            ss_dict[feat_id] ={
                # 
                "Year" : year,
                "StartDLS": start_DLS,
                "EndDLS" : end_DLS,
                # 'lat' : "set in code"
                # 'lon' : set in code
                "Timezone" : utc,
                "SurfaceArea" : hectare,
                'Alt' :  altitude,
                'id' : day,
                'ih': hour,
                "imin" : minute,
                # Fractions
                "Fr_Paved" : LCF_paved,
                "Fr_Bldgs" : LCF_buildings,
                "Fr_EveTr" : LCF_evergreen,
                "Fr_DecTr" : LCF_decidious,
                "Fr_Grass" : LCF_grass,
                "Fr_Bsoil" : LCF_baresoil,
                "Fr_Water" : LCF_water,
                # Irrigation Fraction
                "IrrFr_Paved" : IrrFr_Paved,
                "IrrFr_Bldgs" : IrrFr_Bldgs,
                "IrrFr_EveTr" : irrFr_EveTr,
                "IrrFr_DecTr" : irrFr_DecTr,
                "IrrFr_Grass" : irrFr_Grass,
                "IrrFr_BSoil" : IrrFr_BSoil,
                "IrrFr_Water" : IrrFr_Water,
                # Anthropoghenic Emis
                "QF0_BEU_WD" : QF0_BEU_WD,
                "QF0_BEU_WE" : QF0_BEU_WE,
                # Morphological params
                "H_Bldgs" : IMP_heights_mean,
                "H_EveTr" : IMPveg_heights_mean_eve,
                "H_DecTr" : IMPveg_heights_mean_dec,
                "z0" : '%.3f' % IMP_z0,
                "zd" : '%.3f' % IMP_zd,
                "z"  : '%.3f' % z,
                "FAI_Bldgs" : IMP_fai,
                "FAI_EveTr" : IMPveg_fai_eve,
                "FAI_DecTr" : IMPveg_fai_dec,
                "AreaWall" : (float(IMP_wai) * hectare * 10000.),
                "CondCode" : parameter_dict['Conductance'],
                "SnowCode" : snow_dict['Code'],
                'TrafficRate_WD' : parameter_dict['TrafficRate_WD'],
                'TrafficRate_WE' : parameter_dict['TrafficRate_WE'], 
                'SnowClearingProfWD' : parameter_dict['SnowClearingProfWD'], 
                'SnowClearingProfWE' : parameter_dict['SnowClearingProfWE'], 
                'AnthropogenicCode': parameter_dict['AnthropogenicCode'], 
                'IrrigationCode':  parameter_dict['IrrigationCode'], 
                'WaterUseProfManuWD': parameter_dict['WaterUseProfManuWD'], 
                'WaterUseProfManuWE': parameter_dict['WaterUseProfManuWE'], 
                'WaterUseProfAutoWD': parameter_dict['WaterUseProfAutoWD'], 
                'WaterUseProfAutoWE' : parameter_dict['WaterUseProfAutoWE'], 
                # Population
                "PopDensDay" : '%.3f' % pop_density_day,
                "PopDensNight" : '%.3f' % pop_density_night,
                # Lumps Narp
                "LUMPS_DrRate" : LUMPS_drate,
                "LUMPS_Cover"  : LUMPS_Cover,
                "LUMPS_MaxRes" : LUMPS_MaxRes,
                "NARP_Trans" : NARP_Trans,
                # Water Flow 
                "FlowChange" : flow_change,
                "RunoffToWater" : RunoffToWater,
                "PipeCapacity" : PipeCap,
                "GridConnection1of8" : GridConn1of8,
                "GridConnection2of8" : GridConn2of8,
                "GridConnection3of8" : GridConn3of8,
                "GridConnection4of8" : GridConn4of8,
                "GridConnection5of8" : GridConn5of8,
                "GridConnection6of8" : GridConn6of8,
                "GridConnection7of8" : GridConn7of8,
                "GridConnection8of8" : GridConn8of8,
                "Fraction1of8" : Fraction1of8,
                "Fraction2of8" : Fraction2of8,
                "Fraction3of8" : Fraction3of8,
                "Fraction4of8" : Fraction4of8,
                "Fraction5of8" : Fraction5of8,
                "Fraction6of8" : Fraction6of8,
                "Fraction7of8" : Fraction7of8,
                "Fraction8of8" : Fraction8of8,
                "WithinGridPavedCode" : WhitinGridPav,
                "WithinGridBldgsCode" : WhitinGridBldg,
                "WithinGridEveTrCode" : WhitinGridEve,
                "WithinGridDecTrCode" : WhitinGridDec,
                "WithinGridGrassCode" : WhitinGridGrass,
                "WithinGridUnmanBSoilCode" : WhitinGridUnmanBsoil,
                "WithinGridWaterCode" : WhitinGridWaterCode,

                # ESTM OLD
                "Fr_ESTMClass_Bldgs1": Fr_ESTMClass_Bldgs1,
                "Fr_ESTMClass_Bldgs2": Fr_ESTMClass_Bldgs2,
                "Fr_ESTMClass_Bldgs3": Fr_ESTMClass_Bldgs3,
                "Fr_ESTMClass_Bldgs4": Fr_ESTMClass_Bldgs4,
                "Fr_ESTMClass_Bldgs5": Fr_ESTMClass_Bldgs5,
                "Fr_ESTMClass_Paved1": Fr_ESTMClass_Paved1,
                "Fr_ESTMClass_Paved2": Fr_ESTMClass_Paved2,
                "Fr_ESTMClass_Paved3": Fr_ESTMClass_Paved3,
                "Code_ESTMClass_Bldgs1": Code_ESTMClass_Bldgs1,
                "Code_ESTMClass_Bldgs2": Code_ESTMClass_Bldgs2,
                "Code_ESTMClass_Bldgs3": Code_ESTMClass_Bldgs3,
                "Code_ESTMClass_Bldgs4": Code_ESTMClass_Bldgs4,
                "Code_ESTMClass_Bldgs5": Code_ESTMClass_Bldgs5,
                "Code_ESTMClass_Paved1": Code_ESTMClass_Paved1,
                "Code_ESTMClass_Paved2": Code_ESTMClass_Paved2,
                "Code_ESTMClass_Paved3": Code_ESTMClass_Paved3,  
            }
               # Set Surface codes for each Grid in SiteSelect 
            try:
                ss_dict[feat_id]['Code_Paved'] = nonVeg_dict[feat_id]['Paved']['Code']
                ss_dict[feat_id]['Code_Bldgs'] = nonVeg_dict[feat_id]['Buildings']['Code']
                ss_dict[feat_id]['Code_Bsoil'] = nonVeg_dict[feat_id]['Bare Soil']['Code']
            
                # if grid doesnt contain any typology, set to standard for region/country
                # nonVeg_dict will not have information for grids without typloogy and raise error. Thus, Except statement
            except:
                ss_dict[feat_id]['Code_Paved'] = parameter_dict['Paved']
                ss_dict[feat_id]['Code_Bldgs'] = parameter_dict['Buildings']
                ss_dict[feat_id]['Code_Bsoil'] = parameter_dict['Bare Soil']

            ss_dict[feat_id]['Code_EveTr'] = veg_dict['Evergreen Tree']['Code']
            ss_dict[feat_id]['Code_DecTr'] = veg_dict['Decidous Tree']['Code']
            ss_dict[feat_id]['Code_Grass'] = veg_dict['Grass']['Code']
            ss_dict[feat_id]['Code_Water'] = water_dict['Water']['Code']

            code = "lat"
            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3

            code = "lng"
            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3


        ss_txt_p = plugin_dir +'/Input/SUEWS_SiteSelect.txt' # TODO Fix to set path wihtin UMEP Toolbox
        save_SiteSelect(ss_dict, save_txt_folder, ss_txt_p)

        init_out = output_dir[0] + '/InitialConditions' + str(file_code) + '_' + str(year) + '.nml'
        self.write_to_init(plugin_dir + '/Input/' + 'InitialConditions.nml', init_out)

        # Response to issue #462. Should change in future versions
        copyfile(plugin_dir + '/Input/' + 'ESTMinput.nml', output_dir[0] + "/" + 'ESTMinput.nml')

        copyfile(plugin_dir + '/Input/' + 'SUEWS_SPARTACUS.nml', output_dir[0] + "/" + 'SUEWS_SPARTACUS.nml')
        # TODO Fix withinGridWaterDist
        copyfile(plugin_dir + '/Input/' + 'SUEWS_WithinGridWaterDist.txt', output_dir[0] + "/" + 'WithinGridWaterDist.txt')


    def write_to_init(self, initfilein, initfileout):
        LeafCycle = self.leaf_cycle
        SoilMoisture = self.soil_moisture
        moist = int(SoilMoisture * 1.5)
        snowinitially = 0

        nml = f90nml.read(initfilein)

        nml['initialconditions']['soilstorepavedstate'] = moist
        nml['initialconditions']['soilstorebldgsstate'] = moist
        nml['initialconditions']['soilstoreevetrstate'] = moist
        nml['initialconditions']['soilstoredectrstate'] = moist
        nml['initialconditions']['soilstoregrassstate'] = moist
        nml['initialconditions']['soilstorebsoilstate'] = moist

        # Based on London data
        if LeafCycle == 1:  # Winter
            nml['initialconditions']['gdd_1_0'] = 0
            nml['initialconditions']['gdd_2_0'] = -450
            nml['initialconditions']['laiinitialevetr'] = 4
            nml['initialconditions']['laiinitialdectr'] = 1
            nml['initialconditions']['laiinitialgrass'] = 1.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.3
            nml['initialconditions']['porosity0'] = 0.2
        elif LeafCycle == 2:
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.3
        elif LeafCycle == 3:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.6
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 4:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4.5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 5:  # Summer
            nml['initialconditions']['gdd_1_0'] = 300
            nml['initialconditions']['gdd_2_0'] = 0
            nml['initialconditions']['laiinitialevetr'] = 5.1
            nml['initialconditions']['laiinitialdectr'] = 5.5
            nml['initialconditions']['laiinitialgrass'] = 5.9
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 6:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4, 5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 7:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.5
            nml['initialconditions']['porosity0'] = 0.4
        elif LeafCycle == 8:  # Late Autumn
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.2

        nml['initialconditions']['snowinitially'] = snowinitially

        nml.write(initfileout, force=True)

    def progress_update(self):
        self.steps += 1
        self.dlg.progressBar.setValue(self.steps)


## unused functions
# def hide_show_LCF(self, widget):
    #     if widget.LCF_checkBox.isChecked():
    #         self.LCF_from_file = False
    #         widget.LCF_Frame.show()
    #         widget.pushButtonImportLCF.hide()
    #         widget.textInputLCFData.hide()
    #     else:
    #         self.LCF_from_file = True
    #         widget.LCF_Frame.hide()
    #         widget.pushButtonImportLCF.show()
    #         widget.textInputLCFData.show()

    # def hide_show_IMP(self, widget):
    #     if widget.IMP_checkBox.isChecked():
    #         self.IMP_from_file = False
    #         widget.IMP_Frame.show()
    #         widget.pushButtonImportIMPBuild.hide()
    #         widget.textInputIMPData.hide()
    #     else:
    #         self.IMP_from_file = True
    #         widget.IMP_Frame.hide()
    #         widget.pushButtonImportIMPBuild.show()
    #         widget.textInputIMPData.show()

    # def hide_show_IMPveg(self, widget):
    #     if widget.IMPveg_checkBox.isChecked():
    #         self.IMPveg_from_file = False
    #         widget.IMPveg_Frame.show()
    #         widget.pushButtonImportIMPVeg.hide()
    #         widget.textInputIMPVegData.hide()
    #         widget.checkBox_twovegfiles.hide()
    #         widget.pushButtonImportIMPVeg_eve.hide()
    #         widget.pushButtonImportIMPVeg_dec.hide()
    #         widget.textInputIMPEveData.hide()
    #         widget.textInputIMPDecData.hide()
    #     else:
    #         self.IMPveg_from_file = True
    #         widget.IMPveg_Frame.hide()
    #         widget.pushButtonImportIMPVeg.show()
    #         widget.textInputIMPVegData.show()
    #         widget.checkBox_twovegfiles.show()
    #         widget.pushButtonImportIMPVeg_eve.show()
    #         widget.pushButtonImportIMPVeg_dec.show()
    #         widget.textInputIMPEveData.show()
    #         widget.textInputIMPDecData.show()

    # def grid_layer_changed(self, widget, timezone):

    #     # Try to avoid error when no gridlayer present, or layers added or removed to project
    #     try:
    #         poly = self.layerComboManagerPolygrid.currentLayer()
    #         grid_path = poly.source()
    #         utc = get_utc(grid_path, timezone)
    #         widget.lineEditUTC.setText(str(utc))
    #     except:
    #         pass


