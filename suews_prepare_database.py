# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SUEWSPrepareDatabase
                                 A QGIS plugin
 Prepares inputdata for the SUEWS model using typology database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import  QAction, QMessageBox, QLabel, QLineEdit, QGridLayout, QVBoxLayout, QSpacerItem, QSizePolicy, QFileDialog, QComboBox
from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel, QgsVectorLayer, QgsMessageLog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .suews_prepare_database_dialog import SUEWSPrepareDatabaseDialog
import os.path
from .tabs.main_tab import MainTab
import webbrowser

#These are not needed here later
import numpy as np
import pandas as pd
import os
import glob
from osgeo import gdal, osr
from .Utilities import f90nml
from .Utilities import RoughnessCalcFunction as rg
from .Utilities.misc import saveraster
from .Utilities.db_functions import *
from .Utilities.ssParms import *
# from .db import suews_db
from shutil import copyfile, rmtree
import copy
# from .prepare_workertypo import Worker

os.environ['USE_PYGEOS'] = '0'
import geopandas as gpd
############################################################## 

import processing

# importing native QGIS tools
# from qgis.analysis import QgsNativeAlgorithms
# QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())

################################################################


class SUEWSPrepareDatabase:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SUEWSPrepareDatabase_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&SUEWS Prepare (Database Typologies)')

        self.dlg = SUEWSPrepareDatabaseDialog()

        self.dlg.helpButton.clicked.connect(self.help)

        self.dlg.outputButton.clicked.connect(self.set_output_folder)
        self.dlg.runButton.clicked.connect(self.generate)

        self.outputDialog = QFileDialog()
        self.outputDialog.setFileMode(QFileDialog.Directory)
        self.outputDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.SSDialog = QFileDialog()
        self.SSDialog.setFileMode(QFileDialog.Directory)
        self.SSDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.fileDialog = QFileDialog()
        self.fileDialog.setFileMode(QFileDialog.ExistingFile)

        self.comboBoxCountry = None  
        self.comboBoxRegion = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None

        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        # self.wall_area = None
        self.daypop = 0
        self.typologies = 0
        self.start_DLS = 85
        self.end_DLS = 302
        self.day_since_rain = 0
        self.leaf_cycle = 0
        self.soil_moisture = 100
        self.utc = 0
        self.file_code = ''
        self.steps = 0
        # self.region = None

        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.Metfile_path = None
        # self.land_use_file_path = None
        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True

        self.vertheights ='10, 20'
        self.nlayers = 3
        self.skew = 2

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SUEWSPrepareDatabase', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/suews_prepare_database/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        # self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&SUEWS Prepare (Database Typologies)'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.IMPvegfile_path_dec = None
        self.IMPvegfile_path_eve = None
        self.checkBox_twovegfiles = None
        self.checkBoxTypologies = None
        self.ss_dir = None
        # self.land_use_file_path = None
        self.dlg.textOutput.clear()
        self.setup_tabs()
        self.dlg.show()
        self.dlg.exec_()
        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        self.wall_area = None
        self.layerComboManagerDEM = None
        self.layerComboManagerDSM = None
        self.layerComboManagerLC = None
        self.layerComboManagerPolygridTypo = None
        self.comboBoxRegion = None
        self.comboBoxCountry = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None        

    def help(self):
        url = "https://umep-docs.readthedocs.io/en/latest/pre-processor/Urban%20Energy%20Balance%20SUEWS%20Database%20Manager.html"
        webbrowser.open_new_tab(url)

    def set_output_folder(self):
        self.outputDialog.open()
        result = self.outputDialog.exec_()
        if result == 1:
            self.output_dir = self.outputDialog.selectedFiles()
            self.dlg.textOutput.setText(self.output_dir[0])
            self.dlg.runButton.setEnabled(1)

    def setup_tabs(self):
        self.dlg.tabWidget.clear()
        # self.widget_list = []

        main_tab = MainTab()
        self.setup_maintab(main_tab)

        self.dlg.tabWidget.addTab(main_tab, "Main settings")

    def setup_maintab(self, widget):

        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True
        widget.LCF_Frame.hide()
        widget.IMP_Frame.hide()
        widget.IMPveg_Frame.hide()

        self.comboBoxRegion = True
        self.comboBoxCountry = True
        self.comboBoxPaved = True
        self.comboBoxBuilding = True
        self.comboBoxGrass = True
        self.comboBoxEvrTree = True
        self.comboBoxDecTree = True
        
        timezone = gpd.read_file(self.plugin_dir + '/Input/timezones/ne_10m_time_zones.shp')

        # Region
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        reg = pd.read_excel(db_path, sheet_name='Lod0_Region', index_col= 'ID')
        country = pd.read_excel(db_path, sheet_name='Lod0_Country', index_col= 'ID')
        veg = pd.read_excel(db_path, sheet_name='Lod2_Veg', index_col= 'ID')
        nonveg = pd.read_excel(db_path, sheet_name='Lod2_NonVeg', index_col= 'ID')
        
        nonveg['descOrigin'] = nonveg['Color']  + ' ' + nonveg['Description'] + ', ' + nonveg['Origin']
        veg['descOrigin'] = veg['Description'] + ', ' + veg['Origin']

        building_list = nonveg['descOrigin'].loc[nonveg['Surface'] == 'Buildings']
        paved_list =    nonveg['descOrigin'].loc[nonveg['Surface'] == 'Paved']
        grass_list =    veg['descOrigin'].loc[veg['Surface'] == 'Grass']
        dec_tree_list = veg['descOrigin'].loc[veg['Surface'] == 'Decidous Tree']
        evr_tree_list = veg['descOrigin'].loc[veg['Surface'] == 'Evergreen Tree']

        widget.comboBoxPaved.addItems(sorted(paved_list))
        widget.comboBoxBuilding.addItems(sorted(building_list))
        widget.comboBoxGrass.addItems(sorted(grass_list))
        widget.comboBoxEvrTree.addItems(sorted(evr_tree_list))
        widget.comboBoxDecTree.addItems(sorted(dec_tree_list))

        for cbox in [widget.comboBoxPaved, widget.comboBoxBuilding, widget.comboBoxEvrTree, widget.comboBoxDecTree, widget.comboBoxGrass]:
            cbox.setCurrentIndex(-1)

        reg_list = sorted(list(reg['Region'].unique()))
        widget.comboBoxRegion.addItems(reg_list)     
        widget.comboBoxRegion.setCurrentIndex(-1)
        country['descOrigin'] = country['Country'] + ', ' + country['City']

        widget.comboBoxCountry.addItems(sorted(list(country['descOrigin'].unique())))
        widget.comboBoxCountry.setCurrentIndex(-1)

        widget.LCF_checkBox.stateChanged.connect(lambda: self.hide_show_LCF(widget))
        widget.IMP_checkBox.stateChanged.connect(lambda: self.hide_show_IMP(widget))
        widget.IMPveg_checkBox.stateChanged.connect(lambda: self.hide_show_IMPveg(widget))
        widget.comboBoxRegion.currentIndexChanged.connect(lambda: self.region_changed(widget, country))
        widget.comboBoxCountry.currentIndexChanged.connect(lambda: self.country_changed(widget, country, veg, nonveg, reg))

        # widget.LUF_checkBox.stateChanged.connect(lambda: self.LUF_file(widget))
        # widget.WallArea_checkBox.stateChanged.connect(lambda: self.enable_wall_area(widget))
        widget.checkBoxTypology.stateChanged.connect(lambda: self.use_typologies(widget))
        widget.checkBox_day.stateChanged.connect(lambda: self.popdaystate(widget))

        self.layerComboManagerPolygrid = QgsMapLayerComboBox(widget.widgetPolygonLayer)
        self.layerComboManagerPolygrid.setCurrentIndex(-1)
        self.layerComboManagerPolygrid.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layerComboManagerPolygrid.setFixedWidth(175)
        self.layerComboManagerPolyField = QgsFieldComboBox(widget.widgetPolyField)
        self.layerComboManagerPolyField.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPolygrid.layerChanged.connect(self.layerComboManagerPolyField.setLayer)

        # New for Typology database
        self.layerComboManagerDSM = QgsMapLayerComboBox(widget.widgetDSM)
        self.layerComboManagerDSM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDSM.setFixedWidth(175)
        self.layerComboManagerDSM.setCurrentIndex(-1)
        self.layerComboManagerDEM = QgsMapLayerComboBox(widget.widgetDEM)
        self.layerComboManagerDEM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDEM.setFixedWidth(175)
        self.layerComboManagerDEM.setCurrentIndex(-1)
        self.layerComboManagerLC = QgsMapLayerComboBox(widget.widgetLC)
        self.layerComboManagerLC.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerLC.setFixedWidth(175)
        self.layerComboManagerLC.setCurrentIndex(-1)
        self.layerComboManagerPolygridTypo = QgsMapLayerComboBox(widget.widgetPolygonLayerTypo)
        self.layerComboManagerPolygridTypo.setCurrentIndex(-1)
        self.layerComboManagerPolygridTypo.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layerComboManagerPolygridTypo.setFixedWidth(175)

        # self.reg_cbox = QComboBox(self.dlg.comboBoxRegion)
        # self.country_cbox = QComboBox(self.dlg.comboBoxCountry)
       
        # self.pop_density = FieldCombo(widget.comboBox_popdens, self.fieldgen, initField="")
        self.pop_density = QgsFieldComboBox(widget.widgetPop)
        self.pop_density.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPolygrid.layerChanged.connect(self.pop_density.setLayer)

        self.pop_density_day = QgsFieldComboBox(widget.widgetPopDay)
        self.pop_density_day.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPolygrid.layerChanged.connect(self.pop_density_day.setLayer)

        self.layerComboManagerPolygrid.layerChanged.connect(lambda: self.grid_layer_changed(widget, timezone))

        widget.pushButtonImportLCF.clicked.connect(lambda: self.set_LCFfile_path(widget))
        widget.pushButtonImportIMPVeg.clicked.connect(lambda: self.set_IMPvegfile_path(widget))

        widget.pushButtonImportIMPVeg_eve.clicked.connect(lambda: self.set_IMPvegfile_path_eve(widget))
        widget.pushButtonImportIMPVeg_dec.clicked.connect(lambda: self.set_IMPvegfile_path_dec(widget))

        widget.pushButtonImportIMPBuild.clicked.connect(lambda: self.set_IMPfile_path(widget))
        widget.pushButtonImportMet.clicked.connect(lambda: self.set_metfile_path(widget))
        # widget.pushButtonImportLUF.clicked.connect(lambda: self.set_LUFfile_path(widget))
        

        widget.spinBoxStartDLS.valueChanged.connect(lambda: self.start_DLS_changed(widget.spinBoxStartDLS.value()))
        widget.spinBoxEndDLS.valueChanged.connect(lambda: self.end_DLS_changed(widget.spinBoxEndDLS.value()))

        widget.spinBoxSoilMoisture.valueChanged.connect(lambda: self.soil_moisture_changed(widget.spinBoxSoilMoisture.
                                                                                           value()))
        widget.comboBoxLeafCycle.currentIndexChanged.connect(lambda: self.leaf_cycle_changed(widget.comboBoxLeafCycle.
                                                                                             currentIndex()))
        widget.fileCodeLineEdit.textChanged.connect(lambda: self.file_code_changed(widget.fileCodeLineEdit.text()))
        widget.lineEditUTC.textChanged.connect(lambda: self.utc_changed(widget.lineEditUTC.text()))

        #SS related GUI things
        widget.pushButtonImportSS.clicked.connect(lambda: self.set_SSfolder_path(widget))
        widget.SS_comboBox.currentIndexChanged.connect(lambda: self.height_option_SS(widget.SS_comboBox.currentIndex()))
        widget.SS_LineEdit_constant.textChanged.connect(lambda: self.vertHeights_changed(widget.SS_LineEdit_constant.text()))
        widget.spinBoxLayers.valueChanged.connect(lambda: self.layersSS_changed(widget.spinBoxLayers.value()))
        widget.SS_checkBox_skew.stateChanged.connect(lambda: self.SS_skew(widget))

    def set_SSfolder_path(self, widget):
        self.SSDialog.open()
        result = self.SSDialog.exec_()
        if result == 1:
            self.ss_dir = self.SSDialog.selectedFiles()
            widget.textInputIMPDataSS.setText(self.ss_dir[0])

    def height_option_SS(self, value):
        self.heightMethod = value

    def layersSS_changed(self, value):
        self.nlayers = value

    def vertHeights_changed(self, heights):      
        self.vertheights = heights

    def SS_skew(self, widget):
        if widget.SS_checkBox_skew.isChecked():
            self.skew = 2
        else:
            self.skew = 1

    # def useconstanheight_option_SS(self, widget):
    #     if widget.SS_checkBox_constant.isChecked():
    #         self.heightMethod = 1

    def soil_moisture_changed(self, value):
        self.soil_moisture = value

    def utc_changed(self, index):
        self.utc = index

    def leaf_cycle_changed(self, index):
        self.leaf_cycle = index

    def file_code_changed(self, code):
        self.file_code = code

    def hide_show_LCF(self, widget):
        if widget.LCF_checkBox.isChecked():
            self.LCF_from_file = False
            widget.LCF_Frame.show()
            widget.pushButtonImportLCF.hide()
            widget.textInputLCFData.hide()
        else:
            self.LCF_from_file = True
            widget.LCF_Frame.hide()
            widget.pushButtonImportLCF.show()
            widget.textInputLCFData.show()

    def hide_show_IMP(self, widget):
        if widget.IMP_checkBox.isChecked():
            self.IMP_from_file = False
            widget.IMP_Frame.show()
            widget.pushButtonImportIMPBuild.hide()
            widget.textInputIMPData.hide()
        else:
            self.IMP_from_file = True
            widget.IMP_Frame.hide()
            widget.pushButtonImportIMPBuild.show()
            widget.textInputIMPData.show()

    def hide_show_IMPveg(self, widget):
        if widget.IMPveg_checkBox.isChecked():
            self.IMPveg_from_file = False
            widget.IMPveg_Frame.show()
            widget.pushButtonImportIMPVeg.hide()
            widget.textInputIMPVegData.hide()
            widget.checkBox_twovegfiles.hide()
            widget.pushButtonImportIMPVeg_eve.hide()
            widget.pushButtonImportIMPVeg_dec.hide()
            widget.textInputIMPEveData.hide()
            widget.textInputIMPDecData.hide()
        else:
            self.IMPveg_from_file = True
            widget.IMPveg_Frame.hide()
            widget.pushButtonImportIMPVeg.show()
            widget.textInputIMPVegData.show()
            widget.checkBox_twovegfiles.show()
            widget.pushButtonImportIMPVeg_eve.show()
            widget.pushButtonImportIMPVeg_dec.show()
            widget.textInputIMPEveData.show()
            widget.textInputIMPDecData.show()

    def grid_layer_changed(self, widget, timezone):

        poly = self.layerComboManagerPolygrid.currentLayer()
        grid_path = poly.source()
        utc = get_utc(grid_path, timezone)
        widget.lineEditUTC.setText(str(utc))


    def region_changed(self, widget, country):
        region_sel = widget.comboBoxRegion.currentText()
        country['descOrigin'] = country['Country'] + ', ' + country['City']

        country_list = list(country['descOrigin'].loc[country['Region'] == region_sel])
        widget.comboBoxCountry.clear()
        widget.comboBoxCountry.addItems(country_list)

    def print_reg(self, widget):
        region_sel = widget.comboBoxRegion.currentText()
        return region_sel
   
    def print_country(self, widget):
        country_sel = widget.comboBoxCountry.currentText()
        return country_sel
     
    def country_changed(self, widget, country, veg, nonveg, reg):

        country_sel = widget.comboBoxCountry.currentText()
        reg_sel = widget.comboBoxRegion.currentText()

        self.country_str = country_sel
        self.region_str = reg_sel

        country['descOrigin'] = country['Country'] + ', ' + country['City']
        
        # Uodate region according to country if country is chosen before region
        try:
            if  country.loc[country['descOrigin'] == country_sel]['Region'].item() == reg_sel:
                pass
            else:
                reg_list = [widget.comboBoxRegion.itemText(i) for i in range(widget.comboBoxRegion.count())]
                indexer = reg_list.index(country['Region'].loc[country['descOrigin'] == country_sel].item())
                widget.comboBoxRegion.setCurrentIndex(indexer)
        except:
            pass
      
        try:
            id = country.loc[country['descOrigin'] == country_sel ].index.item()
        except:
            id = country.index[0]

        df_country = country.loc[id]

        def decide_country_region(sel_table, col, comboBox):
            if str(df_country[col]) == 'nan':
                    try:
                        var = reg.loc[reg['Region'] == df_country['Region'], col].item()
                        var_text = sel_table.loc[var, 'descOrigin']
                        cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                        indexer = cbox_list.index(var_text)
                    except:
                        indexer = 0
            else:
                var = df_country[col]
                var_text = sel_table.loc[var, 'descOrigin']
                cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                indexer = cbox_list.index(var_text)
    
            comboBox.setCurrentIndex(indexer)
    
        decide_country_region(nonveg, 'Paved', widget.comboBoxPaved)
        decide_country_region(nonveg, 'Buildings', widget.comboBoxBuilding)
        decide_country_region(veg, 'Evergreen Tree', widget.comboBoxEvrTree)
        decide_country_region(veg, 'Decidous Tree', widget.comboBoxDecTree)
        decide_country_region(veg, 'Grass', widget.comboBoxGrass)

    def use_typologies(self, widget):
        if widget.checkBoxTypology.isChecked():
            self.typologies = 1
        else:
            self.typologies = 0

    def popdaystate(self, widget):
        if widget.checkBox_day.isChecked():
            self.daypop = 1
        else:
            self.daypop = 0

    def set_output_folder(self):
        self.outputDialog.open()
        result = self.outputDialog.exec_()
        if result == 1:
            self.output_dir = self.outputDialog.selectedFiles()
            self.dlg.textOutput.setText(self.output_dir[0])
            self.dlg.runButton.setEnabled(1)

    def set_LCFfile_path(self, widget):
        self.LCFfile_path = self.fileDialog.getOpenFileName()
        widget.textInputLCFData.setText(self.LCFfile_path[0])

    def set_IMPfile_path(self, widget):
        self.IMPfile_path = self.fileDialog.getOpenFileName()
        widget.textInputIMPData.setText(self.IMPfile_path[0])

    def set_IMPvegfile_path(self, widget):
        self.IMPvegfile_path = self.fileDialog.getOpenFileName()
        widget.textInputIMPVegData.setText(self.IMPvegfile_path[0])

    def set_IMPvegfile_path_dec(self, widget):
        self.IMPvegfile_path_dec = self.fileDialog.getOpenFileName()
        widget.textInputIMPDecData.setText(self.IMPvegfile_path_dec)

    def set_IMPvegfile_path_eve(self, widget):
        self.IMPvegfile_path_dec = self.fileDialog.getOpenFileName()
        widget.textInputIMPEveData.setText(self.IMPvegfile_path_eve[0])

    def set_metfile_path(self, widget):
        self.Metfile_path = self.fileDialog.getOpenFileName()
        widget.textInputMetData.setText(self.Metfile_path[0])

    # def set_LUFfile_path(self, widget):
    #     self.land_use_file_path = self.fileDialog.getOpenFileName()
    #     widget.textInputLUFData.setText(self.land_use_file_path[0])

    def start_DLS_changed(self, value):
        self.start_DLS = value

    def end_DLS_changed(self, value):
        self.end_DLS = value

    def unload_widget(self):
        self.dlg.tabWidget.clear()

    def generate(self, widget):

        # First check that all part of the interface have been filled in correclty
        # output dir
        if self.output_dir is None:
            QMessageBox.critical(self.dlg, "Error", "No output directory selected")
            return  

        # metfile
        year = None
        year2 = None
        if self.Metfile_path is None:
            QMessageBox.critical(self.dlg, "Error", "Meteorological data file has not been provided,"
                                                " please check the main tab")
            return
        elif os.path.isfile(self.Metfile_path[0]):
            with open(self.Metfile_path[0]) as metfile:
                next(metfile)
                for line in metfile:
                    split = line.split()
                    if year == split[0]:
                        break
                    else:
                        if year2 == split[0]:
                            year = split[0]
                            break
                        elif year is None:
                            year = split[0]
                        else:
                            year2 = split[0]
        else:
            QMessageBox.critical(self.dlg, "Error", "Could not find the file containing meteorological data")
            return

        # # check polygon grid
        poly = self.layerComboManagerPolygrid.currentLayer()
        if poly is None:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        if not poly.geometryType() == 2:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        poly_field = self.layerComboManagerPolyField.currentField()
        if poly_field == '':
            QMessageBox.critical(None, "Error", "An attribute field with unique fields must be selected")
            return

        vlayer = QgsVectorLayer(poly.source(), "polygon", "ogr")

        map_units = vlayer.crs().mapUnits()
        if not map_units == 0 or map_units == 1 or map_units == 2:
            QMessageBox.critical(self.dlg, "Error", "Could not identify the map units of the polygon layer coordinate "
                                 "reference system")
            return

        # population density  from polygon grid
        if self.pop_density.currentField() == '':
            QMessageBox.critical(None, "Error", "An attribute field including night-time population density (pp/ha) must be selected")
            return

        if self.daypop == 1:
            if self.pop_density_day.currentField() == '':
                QMessageBox.critical(None, "Error", "An attribute field including working population density (pp/ha) must be selected")
                return            

        # Leaf cycle
        if self.leaf_cycle == 0:
            QMessageBox.critical(self.dlg, "Error", "No leaf cycle period has been selected")
            return
        else:
            if not (self.leaf_cycle == 1 or self.leaf_cycle == 5):
                QMessageBox.critical(self.dlg,"Warning", "A transition period between Winter and Summer has been "
                                     "choosen. Preferably start the model run during Winter or Summer.")

        if self.LCF_from_file:
            if self.LCFfile_path is None:
                QMessageBox.critical(None, "Error", "Land cover fractions file has not been provided,"
                                                        " please check the main tab")
                return
            if not os.path.isfile(self.LCFfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing land cover fractions")
                return

        # Morphometric and land cover files
        if self.IMP_from_file:
            if self.IMPfile_path is None:
                QMessageBox.critical(None, "Error", "Building morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing building morphology")
                return

        if self.IMPveg_from_file:
            if self.IMPvegfile_path is None:
                QMessageBox.critical(None, "Error", "Vegetation morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPvegfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing vegetation morphology")
                return

        if self.file_code == '':
            QMessageBox.critical(None, "Error", "Specify a file code prefix")
            return

        vlayer.source()

        # # DSM layer for aggegation
        dsmlayer = self.layerComboManagerDSM.currentLayer()
        # if dsmlayer is None:
        #     QMessageBox.critical(self.dlg, "Error", "No valid ground and building DSM is selected")
        #     return

        demlayer = self.layerComboManagerDEM.currentLayer()
        # if demlayer is None:
        #     QMessageBox.critical(self.dlg, "Error", "No valid DEM selected")
        #     return

        # # Land cover layer for aggegation
        lclayer = self.layerComboManagerLC.currentLayer()
        # if lclayer is None:
        #     QMessageBox.critical(self.dlg, "Error", "No valid land cover grid is selected")
        #     return   

        polyTypolayer = self.layerComboManagerPolygridTypo.currentLayer()
        # if polyTypolayer is None:
        #     QMessageBox.critical(None, "Error", "No valid Urban typology polygon layer is selected")
        #     return     

  
        # if self.
        #     use_typologies = 'yes'
        # else:
        #     use_typologies = 'no' 

        #TODO add check for Region,
        #TODO add checker for CRS 
        #  

        # self.dlg.progressBar.setMaximum(vlayer.featureCount())     

        #Here worker loop starts. We make function. Then it is easier to put in worker latery

        # wait here. How shall we do????

        # QMessageBox.critical(None, "OK", "Frrk")
        # return  

        self.generateSiteSelect(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
                         self.LCF_Paved, self.LCF_Buildings, self.LCF_Evergreen, self.LCF_Decidious, self.LCF_Grass, self.LCF_Baresoil,
                         self.LCF_Water, self.IMP_from_file, self.IMPfile_path, self.IMP_mean_height, self.IMP_z0, self.IMP_zd,
                         self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, self.IMPveg_mean_height_eve,
                         self.IMPveg_mean_height_dec, self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, 
                         self.plugin_dir, map_units,
                         self.output_dir, self.day_since_rain, self.leaf_cycle, self.soil_moisture, self.file_code,
                         self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop,
                         polyTypolayer, dsmlayer, demlayer, lclayer, self.region_str, self.country_str, self.typologies,
                         self.heightMethod, self.vertheights, self.nlayers, self.skew, self.ss_dir)

        # self.startWorker(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
        #                  self.LCF_Paved, self.LCF_Buildings, self.LCF_Evergreen, self.LCF_Decidious, self.LCF_Grass, self.LCF_Baresoil,
        #                  self.LCF_Water, self.IMP_from_file, self.IMPfile_path, self.IMP_mean_height, self.IMP_z0, self.IMP_zd,
        #                  self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, self.IMPveg_mean_height_eve,
        #                  self.IMPveg_mean_height_dec, self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, 
        #                  self.plugin_dir, map_units,
        #                  self.output_dir, self.day_since_rain, self.leaf_cycle, self.soil_moisture, self.file_code,
        #                  self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop)


    def generateSiteSelect(self,vlayer, poly_field, Metfile_path, start_DLS, end_DLS, LCF_from_file, LCFfile_path,
                         LCF_Paved, LCF_Buildings, LCF_Evergreen, LCF_Decidious, LCF_Grass, LCF_Baresoil,
                         LCF_Water, IMP_from_file, IMPfile_path, IMP_mean_height, IMP_z0, IMP_zd,
                         IMP_fai, IMPveg_from_file, IMPvegfile_path, IMPveg_mean_height_eve,
                         IMPveg_mean_height_dec, IMPveg_fai_eve, IMPveg_fai_dec, pop_density, 
                         plugin_dir, map_units,
                         output_dir, day_since_rain, leaf_cycle, soil_moisture, file_code,
                         utc, checkBox_twovegfiles, IMPvegfile_path_dec, IMPvegfile_path_eve, pop_density_day, daypop,
                         polyTypolayer, dsmlayer, demlayer, lclayer, region_str, country_str, checkBoxTypologies,
                         heightMethod, vertheights, nlayers, skew, ss_dir):

        save_txt_folder = output_dir[0]+ '/'
        temp_folder = 'C:/temp/agg/' # Read from UMEP Check in UWG Prepare
        build_raster_out = temp_folder + 'buildings.tif'

        ss_dict = {}
        veg_dict = {}
        nonVeg_dict = {}
        blend_dict= {}
        dict_out = {}

        surface_list = ['Paved', 'Buildings','Bare Soil']

        frac_to_surf_dict = {
            'hist_1' : 'Paved', 
            'hist_2' : 'Buildings', 
            'hist_3' : 'Grass', 
            'hist_4' : 'Evergreen Tree' ,
            'hist_5' : 'Decidous Tree' , 
            'hist_6' : 'Bare Soil',
            'hist_7' : 'Water',
            } 

        surf_to_code_dict = {
            'Paved' : 'Code_Paved',
            'Buildings' : 'Code_Bldgs',
            'Bare Soil': 'Code_Bsoil',
            'Grass' : 'Code_Grass',
            'Evergreen Tree' : 'Code_EveTr',
            'Decidous Tree' :  'Code_DecTr',
            'Water' : 'Code_Water' 
            } 

        # Read DB
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por, reg, snow, AnEm, prof, ws, soil, ESTM, irr, country, type_id_dict,country_id_dict, reg_id_dict = read_DB(db_path)

        country_conv_dict = {} 
        reg_conv_dict = {}
        for index in list(country.index):
            country_conv_dict[index] = country.loc[index, 'Country'] + ', ' + country.loc[index, 'City']
        country_conv_dict_inv = {v: k for k, v in country_conv_dict.items()}
        for index in list(reg.index):
            reg_conv_dict[index] = reg.loc[index, 'Region']
        reg_conv_dict_inv = {v: k for k, v in reg_conv_dict.items()}
    
        # reg_sel = reg.loc[[reg_conv_dict_inv[region_str]]]
        country_sel = country.loc[[country_conv_dict_inv[country_str]]]

    
        column_list = country.drop(columns = ['Region','Country','City']).columns
        column_dict = {}
        for column in column_list:
            column_dict[column] = decide_country_or_region(column, country_sel, reg)

        # Fill Anthropogeinc Emissions
        AnEm_dict = fill_SUEWS_AnthropogenicEmission(column_dict['AnthropogenicCode'], column_dict, AnEm) # FIX!
        snow_dict = fill_SUEWS_Snow(column_dict['SnowCode'], snow, alb, em, ANOHM)
        water_dict = fill_SUEWS_Water(column_dict['Water'], water, alb, em, st, dr, ANOHM, ws, column_dict)
        cond_dict = sel_to_dict(cnd, 'Cnd', column_dict)
        # snow_dict = sel_to_dict(snow, 'Water_Code', column_dict)

        if LCF_from_file:
            LCF_dict = read_morph_txt(LCFfile_path[0])

        if IMP_from_file:
            IMP_dict = read_morph_txt(IMPfile_path[0])

        if IMPveg_from_file:
            IMPveg_dict = read_morph_txt(IMPvegfile_path[0])
        
        if checkBoxTypologies == 1:
        # DEM & DSM to array

            gdal.AllRegister()
            provider = demlayer.dataProvider()
            filePath_dem = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_dem)
            dem_arr = dataSet.ReadAsArray().astype(float)

            provider = dsmlayer.dataProvider()
            filePath_dsm = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_dsm)
            dsm_arr = dataSet.ReadAsArray().astype(float)
            
            provider = lclayer.dataProvider()
            filePath_lc = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_lc)
            # lc_arr = dataSet.ReadAsArray().astype(float)

            # # Clean temp folder
            temp_folder = 'C:/temp/agg'
            try:
                rmtree(temp_folder)
            except OSError as e:
                print ("Error: %s - %s." % (e.filename, e.strerror))

            os.mkdir(temp_folder)

            output = {}

            # parin = {'INPUT': vlayer,
            #          'OUTPUT':'TEMPORARY_OUTPUT'}

            # output['bbox'] = processing.run("native:boundingboxes",parin) 
            # TODO Clip rastesr to speed up process
            # parin = {
            #     'INPUT':vlayer,
            #     'OVERLAY': output['bbox'],
            #     'OUTPUT':'TEMPORARY_OUTPUT'}
            # output['clip'] = processing.run("native:clip", parin)
            
            # Grid classified shp-file containing SUEWS typologies
            intersectPrefix = 'i'
            parin = { 'INPUT' : vlayer, 
            'INPUT_FIELDS' : [], 
            'OUTPUT' : 'TEMPORARY_OUTPUT',#urbantypelayer, 
            'OVERLAY' : polyTypolayer, 
            'OVERLAY_FIELDS' : [], 
            'OVERLAY_FIELDS_PREFIX' : intersectPrefix }

            output['gridded_shp'] = processing.run('native:intersection', parin)

            # isolate buildings in dsm to be able to calculate mean height
            build_arr = dsm_arr-dem_arr
            build_arr[np.where(build_arr < 2.5)] = np.nan # CHECK THISOUT!
            saveraster(gdal.Open(filePath_dsm), build_raster_out, build_arr)

            type_id = 'inewfield'
            height_prefix = '_bldheight'
            
            parin = {
                'INPUT':output['gridded_shp']['OUTPUT'],
                'INPUT_RASTER': build_raster_out,
                'RASTER_BAND':1,
                'COLUMN_PREFIX': height_prefix,
                'STATISTICS':[2], # [2] == mean
                'OUTPUT': 'TEMPORARY_OUTPUT'}
            # Zonal statistics to calculate mean height within gridded polygon layer
            output['gridded_shp_bld'] = processing.run("native:zonalstatisticsfb", parin)

            # Zonal histogram to calculate fractions of lc in all gridded typologies
            prefix = 'hist_'

            parin =  {
                'INPUT_RASTER': filePath_lc,
                'RASTER_BAND': 1,
                'INPUT_VECTOR': output['gridded_shp']['OUTPUT'],
                'COLUMN_PREFIX': prefix,
                'OUTPUT': 'TEMPORARY_OUTPUT'}

            output['gridded_shp_lc'] = processing.run("native:zonalhistogram",parin)

            # obtain pixelsize of raster in order to be able to calculate fractions later on
            lc_raster = gdal.Open(filePath_lc)
            lc_raster_gt = lc_raster.GetGeoTransform()
            pixelSizeX = lc_raster_gt[1]

            # vector layer gridded typologies
            vlayer_gt = output['gridded_shp']['OUTPUT'] #QgsVectorLayer(, "polygon", "ogr")

            field_list= []
            for fieldName in vlayer_gt.fields():
                field_list.append(fieldName.name())

            type_index = field_list.index(type_id)
            pai_dict = {}

            for feature in vlayer_gt.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                pai_dict[feat_id] = { i : 0 for i in list(vlayer_gt.uniqueValues(type_index))}

            for feature in vlayer_gt.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                typology = feature.attribute(type_id)
                area = feature.geometry().area()

                pai_dict[feat_id][typology] = area

            # vector layer with building heights
            vlayer_bh =output['gridded_shp_bld']['OUTPUT']

            field_list= []
            for fieldName in vlayer_bh.fields():
                field_list.append(fieldName.name())

            type_index = field_list.index(type_id)
            area_dict = {}

            for feature in vlayer_bh.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                area_dict[feat_id] = { i : 0 for i in list(vlayer_bh.uniqueValues(type_index))}
                pai_dict[feat_id] = { i : 0 for i in list(vlayer_bh.uniqueValues(type_index))}

            for feature in vlayer_bh.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                typology = feature.attribute(type_id)
                build_h = feature.attribute(height_prefix+'mean')
                area = feature.geometry().area()
                try: 
                    volume = area * build_h
                except:
                    volume = area * 1
                
                area_dict[feat_id][typology] = area_dict[feat_id][typology] + volume
            
            frac_dict_bh = {} # create a new dictionary with fracions and remove typologies with fracion 0

            for i in area_dict:
                total_vol = sum(area_dict[i].values())
                frac_dict_bh[i] = {k:(v/total_vol) for k, v in area_dict[i].items() }
                frac_dict_bh[i] = {k:v for (k,v) in frac_dict_bh[i].items() if v > 0}

            # Calculate fractions of LC_classes hist_number indicate same as SUEWS surfaces, paved, building etc.
        
            vlayer_lc = output['gridded_shp_lc']['OUTPUT']

            field_list= ['hist_1', 'hist_2','hist_3','hist_4', 'hist_5','hist_6','hist_7'] # 'hist_1' : Paved, 'hist_2' : Buildings, 'hist_3' : 'Evergreen Trees', 'hist_4' : 'Evergreen Trees', 'hist_5': 'Grass' ,'hist_6': 'Bare Soil', 'hist_7' : 'Water'

            types_list= []
            for fieldName in vlayer_lc.fields():
                types_list.append(fieldName.name())

            type_index = types_list.index(type_id)

            area_dict = {}

            for feature in vlayer_lc.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                area_dict[feat_id] = { i : { i : 0 for i in field_list} for i in list(vlayer_lc.uniqueValues(type_index))}

            for feature in vlayer_lc.getFeatures():
                
                for gridtype in field_list:
                    feat_id = int(feature.attribute(poly_field))
                    typology = feature.attribute(type_id)
                    try:
                        area_dict[feat_id][typology][gridtype] = area_dict[feat_id][typology][gridtype] + feature.attribute(gridtype) #area_dict[feat_id][typology] + volume
                    except:
                        area_dict[feat_id][typology][gridtype] = 0 # 0 if no frac exist

            frac_dict_lc = {} # create a new dictionary with fracions  
            typology_list = list(area_dict[list(area_dict.keys())[0]].keys())

            for i in area_dict:
                frac_dict_lc[i] ={}
                for j in typology_list:
                    if sum(area_dict[i][j].values()) > 0: # only select typologies active in the grid
                        frac_dict_lc[i][j] = {k:(v/pixelSizeX) for k, v in area_dict[i][j].items()}
                        frac_dict_lc[i][j] = {k:v for (k,v) in area_dict[i][j].items() if v > 0} # remove typologies with fracion 0

            frac_dict_surf = {}
            for id in frac_dict_lc:
                frac_dict_surf[id] = {}
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        frac_dict_surf[id][surf] = 0
                        
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        try:
                            frac_dict_surf[id][surf] = frac_dict_surf[id][surf] + frac_dict_lc[id][typology][surf]
                        except:
                            pass 

            for id in frac_dict_lc:              
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        try:
                            frac_dict_lc[id][typology][surf] = frac_dict_lc[id][typology][surf] / frac_dict_surf[id][surf]
                        except:
                            pass
        
            for id in frac_dict_bh: # CHange to ID for GRID!

                type_list = list(frac_dict_bh[id].keys())
                type_list_int = []

                for element in type_list:
                    type_list_int.append(type_id_dict[element])

                ss_dict[id] = {}
                dict_out[id] = {}
        
                # SUEWS_NonVeg
                nonVeg_dict[id] = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = type_list_int)
        
                blend_dict[id] = {}
                
                for surface in surface_list:
                    blend_dict[id][surface] = {}
                    dict_out[id][surface] = {}

    
                    params = list(nonVeg_dict[id][surface_list[0]][type_list_int[0]].keys())

                    for param in params:
                        blend_dict[id][surface][param] = {}

                        for typology in type_list_int:
                            blend_dict[id][surface][param][typology] = nonVeg_dict[id][surface][typology][param]

                    # Check if the codes needs to be averaged or not
                    unique_values = list(set(list(blend_dict[id][surface]['Code'].values())))        

                    if len(unique_values) == 1:
                        ss_dict[id][surf_to_code_dict[surface]] = str(unique_values[0]) # if they all same, just set same code
                        dict_out[id][surface] = nonVeg_dict[id][surface][typology]
                    else:
                        tab, OHM, ESTM = blend_nonveg(blend_dict, surface, frac_dict_bh, frac_dict_lc, id, ESTM, OHM,type_id_dict, frac_to_surf_dict, column_dict)
                        ss_dict[id][surf_to_code_dict[surface]] = tab[surface]['Code']
                        dict_out[id][surface] = tab[surface]
                        
            dict_out[9999] = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = False)

            save_NonVeg_types(dict_out, save_txt_folder)
        
            nonVeg_dict = dict_out.copy()
            
            
        else:
            nonVeg_dict = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = False)
            save_SUEWS_txt(pd.DataFrame.from_dict(nonVeg_dict, orient='index').set_index('Code'), 'SUEWS_NonVeg.txt', save_txt_folder)      

        veg_dict = fill_SUEWS_Veg(Type, veg, alb, em, LAI, st, LGP, dr, VG, ANOHM,  MVCND, por, ws, urbType = False, column_dict = column_dict)
        save_SUEWS_txt(pd.DataFrame.from_dict(veg_dict, orient='index').set_index('Code'), 'SUEWS_Veg.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(AnEm_dict, orient = 'index').T.set_index('Code'), 'SUEWS_AnthropogenicEmission.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(water_dict, orient = 'index').set_index('Code'), 'SUEWS_Water.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(cond_dict, orient = 'index').T.set_index('Code'), 'SUEWS_Conductance.txt', save_txt_folder)

        save_snow(snow_dict, save_txt_folder)

        # Save Profiles
        profiles = ['TrafficRate_WD','TrafficRate_WE', 'EnergyUseProfWD','EnergyUseProfWE','ActivityProfWD','ActivityProfWE','PopProfWD','PopProfWE', 'SnowClearingProfWD', 'SnowClearingProfWE','WaterUseProfManuWD','WaterUseProfManuWE','WaterUseProfAutoWD','WaterUseProfAutoWE']        
        profiles_list = []
        for i in profiles:
            profiles_list.append(column_dict[i])
            profiles_list = list(set(profiles_list))

        fill_SUEWS_profiles(profiles_list, save_txt_folder, prof) # TODO IMORGON!
        # presave leads to save_SUEWS_txt
        # presave(prof, 'Profiles', profiles_list, save_txt_folder)
        presave(irr, 'Irrigation', [column_dict['IrrigationCode']], save_txt_folder)
        presave(soil, 'Soil', [column_dict['SoilTypeCode']], save_txt_folder)

        # Spartacus
        # ? 

        ########################### CALC ################################
        

        ESTM_list = []
        OHM_list = []
        BIOCO2_list = []

        for dict_sel in [nonVeg_dict, veg_dict, snow_dict, water_dict ]:
        
            try:
                for i in dict_sel.keys():
                    try:
                        ESTM_list.append(dict_sel[i]['ESTMCode'])
                    except:
                        pass
                    try:
                        OHM_list.append(dict_sel[i]['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel[i]['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel[i]['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel[i]['OHMCode_WinterDry'])
                    except:
                        OHM_list.append(dict_sel['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel['OHMCode_WinterDry'])

                    try:
                        BIOCO2_list.append(dict_sel[i]['BiogenCO2Code'])
                    except:
                        pass
            except:
                for feat_id in list(dict_sel.keys()):
                    for surf in surface_list:
                            ESTM_list.append(dict_sel[feat_id][surf]['ESTMCode'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerWet'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerDry'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])

        ESTM_list = list(set(ESTM_list))
        OHM_list = list(set(OHM_list))
        BIOCO2_list = list(set(BIOCO2_list))

        presave(ESTM, 'ESTMCoefficients', ESTM_list, save_txt_folder)
        presave(OHM, 'OHMCoefficients', OHM_list, save_txt_folder)
        presave(BIOCO2, 'BiogenCO2', BIOCO2_list, save_txt_folder)

        # ################################################################################################################################
        
        # ################################################################################################################################

        ind = 1
        # Loop Start for each Grid
        for feature in vlayer.getFeatures():

            # if self.killed is True:
            #     break
            # new_line = [None] * (len(self.nbr_header) - 3)
            # print_line = True
            # feat_id = int(feature.attribute(self.poly_field))
            # code = "Grid"
            # index = self.find_index(code)
            # new_line[index] = str(feat_id)
            # print('Processing ID: ' + str(feat_id))
            # # if killed is True:
            # #     break
            # # new_line = [None] * (len(nbr_header) - 3)
            # print_line = True
            feat_id = int(feature.attribute(poly_field))
    
            print('Processing ID: ' + str(feat_id))
            year = None
            year2 = None
            ss_dict[feat_id] = {}

            # Write GridLayoutXXX.nml
            print(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt')
            ssVect = np.loadtxt(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt', skiprows = 1) #vertical info from IMP calc
            writeGridLayout(ssVect, heightMethod, vertheights, nlayers, skew, file_code, str(feat_id), save_txt_folder)

            try:
                ss_dict[feat_id]['Code_Paved'] = nonVeg_dict[feat_id]['Paved']['Code']
                ss_dict[feat_id]['Code_Bldgs'] = nonVeg_dict[feat_id]['Buildings']['Code']
                ss_dict[feat_id]['Code_Bsoil'] = nonVeg_dict[feat_id]['Bare Soil']['Code']
            
                # if grid doesnt contain any typology, set to standard for region/country
                # nonVeg_dict will not have information for grids without typloogy and raise error
            except:
                ss_dict[feat_id]['Code_Paved'] = column_dict['Paved']
                ss_dict[feat_id]['Code_Bldgs'] = column_dict['Buildings']
                ss_dict[feat_id]['Code_Bsoil'] = column_dict['Bare Soil']

            ss_dict[feat_id]['Code_EveTr'] = veg_dict['Evergreen Tree']['Code']
            ss_dict[feat_id]['Code_DecTr'] = veg_dict['Decidous Tree']['Code']
            ss_dict[feat_id]['Code_Grass'] = veg_dict['Grass']['Code']
            ss_dict[feat_id]['Code_Water'] = water_dict['Water']['Code']

            if Metfile_path is None:
                QMessageBox.critical(None, "Error", "Meteorological data file has not been provided,"
                                                    " please check the main tab")
                return
            elif os.path.isfile(Metfile_path[0]):
                with open(Metfile_path[0]) as file:
                    next(file)
                    for line in file:
                        split = line.split()
                        if year == split[0]:
                            break
                        else:
                            if year2 == split[0]:
                                year = split[0]
                                break
                            elif year is None:
                                year = split[0]
                            else:
                                year2 = split[0]

                # figure out the time res of input file
                if ind == 1:
                    met_old = np.genfromtxt(Metfile_path[0], skip_header=1, skip_footer=2)
                    id = met_old[:, 1]
                    it = met_old[:, 2]
                    imin = met_old[:, 3]
                    dectime0 = id[0] + it[0] / 24 + imin[0] / (60 * 24)
                    dectime1 = id[1] + it[1] / 24 + imin[1] / (60 * 24)
                    res = int(np.round((dectime1 - dectime0) * (60 * 24)))
                    ind = 999

            else:
                QMessageBox.critical(None, "Error",
                                        "Could not find the file containing meteorological data")
                return

            old_cs = osr.SpatialReference()
            vlayer_ref = vlayer.crs().toWkt()
            old_cs.ImportFromWkt(vlayer_ref)

            wgs84_wkt = """
            GEOGCS["WGS 84",
                DATUM["WGS_1984",
                    SPHEROID["WGS 84",6378137,298.257223563,
                        AUTHORITY["EPSG","7030"]],
                    AUTHORITY["EPSG","6326"]],
                PRIMEM["Greenwich",0,
                    AUTHORITY["EPSG","8901"]],
                UNIT["degree",0.01745329251994328,
                    AUTHORITY["EPSG","9122"]],
                AUTHORITY["EPSG","4326"]]"""

            new_cs = osr.SpatialReference()
            new_cs.ImportFromWkt(wgs84_wkt)

            transform = osr.CoordinateTransformation(old_cs, new_cs)

            centroid = feature.geometry().centroid().asPoint()
            area = feature.geometry().area()

            if map_units == 0:
                hectare = area * 0.0001 # meter

            elif map_units == 1:
                hectare = area / 107640. # square foot

            else:
                hectare = area
            gdalver = float(gdal.__version__[0])
            lonlat = transform.TransformPoint(centroid.x(), centroid.y())
            code = "lat"

            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3

            code = "lng"
            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3

            altitude = 0
            day = 1
            hour = 0
            minute = 0

            if LCF_from_file:
                LCF_paved     = LCF_dict[feat_id]['Paved']
                LCF_buildings = LCF_dict[feat_id]['Buildings']
                LCF_evergreen = LCF_dict[feat_id]['EvergreenTrees']
                LCF_decidious = LCF_dict[feat_id]['DecidiousTrees']
                LCF_grass     = LCF_dict[feat_id]['Grass']
                LCF_baresoil  = LCF_dict[feat_id]['Baresoil']
                LCF_water     = LCF_dict[feat_id]['Water']

                # found_LCF_line = False
                # with open(LCFfile_path[0]) as file:
                #     next(file)
                #     for line in file:
                #         split = line.split()
                #         print(split)
                #         try:
                #             if feat_id == int(split[0]):
                #                 LCF_paved = split[1]
                #                 LCF_buildings = split[2]
                #                 LCF_evergreen = split[3]
                #                 LCF_decidious = split[4]
                #                 LCF_grass = split[5]
                #                 LCF_baresoil = split[6]
                #                 LCF_water = split[7]
                #                 found_LCF_line = True
                #                 break
                #         except:
                #             pass    
                #     if not found_LCF_line:
                #         LCF_paved = -999
                #         LCF_buildings = -999
                #         LCF_evergreen = -999
                #         LCF_decidious = -999
                #         LCF_grass = -999
                #         LCF_baresoil = -999
                #         LCF_water = -999
                #         print_line = False

            else:
                LCF_paved = feature.attribute(LCF_paved.getFieldName())
                LCF_buildings = feature.attribute(LCF_buildings.getFieldName())
                LCF_evergreen = feature.attribute(LCF_evergreen.getFieldName())
                LCF_decidious = feature.attribute(LCF_decidious.getFieldName())
                LCF_grass = feature.attribute(LCF_grass.getFieldName())
                LCF_baresoil = feature.attribute(LCF_baresoil.getFieldName())
                LCF_water = feature.attribute(LCF_water.getFieldName())

            irrFr_EveTr = 0
            irrFr_DecTr = 0
            irrFr_Grass = 0
            IrrFr_Bldgs = 0
            IrrFr_Paved = 0
            IrrFr_Water = 0
            IrrFr_BSoil = 0

            TrafficRate_WD = 0.01 ## Already in dict
            TrafficRate_WE = 0.01 ## Already in dict

            QF0_BEU_WD = 0.88 ## Already in dict
            QF0_BEU_WE = 0.88 ## Already in dict
           
            if IMP_from_file:
                IMP_heights_mean = IMP_dict[feat_id]['zH']
                IMP_z0 = IMP_dict[feat_id]['z0']
                IMP_zd = IMP_dict[feat_id]['zd']
                IMP_fai = IMP_dict[feat_id]['fai']
                IMP_max = IMP_dict[feat_id]['zHmax']
                IMP_sd = IMP_dict[feat_id]['zHstd']
                IMP_wai = IMP_dict[feat_id]['wai']

                # with open(IMPfile_path[0]) as file:
                #     next(file)
                #     for line in file:
                #         split = line.split()
                #         if feat_id == int(split[0]):
                #             IMP_heights_mean = split[3]
                #             IMP_z0 = split[6]
                #             IMP_zd = split[7]
                #             IMP_fai = split[2]
                #             IMP_max = split[4]
                #             IMP_sd = split[5]
                #             IMP_wai = split[8]
                #             found_IMP_line = True
                #             break
                #     if not found_IMP_line:
                #         IMP_heights_mean = -999
                #         IMP_z0 = -999
                #         IMP_zd = -999
                #         IMP_fai = -999
                #         IMP_wai = -999
                #         print_line = False
            else:
                IMP_heights_mean = feature.attribute(IMP_mean_height.getFieldName())
                IMP_z0 = feature.attribute(IMP_z0.getFieldName())
                IMP_zd = feature.attribute(IMP_zd.getFieldName())
                IMP_fai = feature.attribute(IMP_fai.getFieldName())
                IMP_wai = feature.attribute(IMP_wai.getFieldName())

            if IMPveg_from_file:
                IMPveg_heights_mean_eve = IMPveg_dict[feat_id]['zH']
                IMPveg_heights_mean_dec = IMPveg_dict[feat_id]['zH']
                IMPveg_fai_eve = IMPveg_dict[feat_id]['fai']
                IMPveg_fai_dec = IMPveg_dict[feat_id]['fai']
                IMPveg_max_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_sd_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_max_dec = IMPveg_dict[feat_id]['zHstd']
                IMPveg_sd_dec = IMPveg_dict[feat_id]['zHstd']



                # found_IMPveg_line = False   

                # with open(IMPvegfile_path[0]) as file:
                #     for line in file:
                #         split = line.split()
                #         if feat_id == int(split[0]):
                #             IMPveg_heights_mean_eve = split[3]
                #             IMPveg_heights_mean_dec = split[3]
                #             IMPveg_fai_eve = split[2]
                #             IMPveg_fai_dec = split[2]
                #             IMPveg_max_eve = split[4]  #TODO not used yet
                #             IMPveg_sd_eve = split[5]  #TODO not used yet
                #             IMPveg_max_dec = split[4]
                #             IMPveg_sd_dec = split[5]
                #             found_IMPveg_line = True
                #             break
                #     if not found_IMPveg_line:
                #         IMPveg_heights_mean_eve = -999
                #         IMPveg_heights_mean_dec = -999
                #         IMPveg_fai_eve = -999
                #         IMPveg_fai_dec = -999
                #         print_line = False
            else:
                IMPveg_heights_mean_eve = feature.attribute(IMPveg_mean_height_eve.getFieldName())
                IMPveg_heights_mean_dec = feature.attribute(IMPveg_mean_height_dec.getFieldName())
                IMPveg_fai_eve = feature.attribute(IMPveg_fai_eve.getFieldName())
                IMPveg_fai_dec = feature.attribute(IMPveg_fai_dec.getFieldName())

            # New calcualtion of rouhgness params v2017 (Kent et al. 2017b)
            # Evergreen not yet included in the calculations
            LCF_de = float(LCF_decidious)
            LCF_ev = float(LCF_evergreen)
            LCF_bu = float(LCF_buildings)
            LCF_tr = LCF_de + LCF_ev # temporary fix while ev and de is not separated, issue 155
            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                zH = 0
                zMAx = 0
            else:
                zH = (float(IMP_heights_mean) * LCF_bu + float(IMPveg_heights_mean_eve) * LCF_ev + float(IMPveg_heights_mean_dec) * LCF_de) / (LCF_bu + LCF_ev + LCF_de)                    
                zMax = max(float(IMPveg_max_dec),float(IMP_max))

            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                sdComb = 0
                IMP_z0 = 0
                IMP_zd = 0
                # sdTree = np.sqrt((IMPveg_sd_eve ^ 2 / LCF_evergreen * area) + (IMPveg_sd_dec ^ 2 / LCF_decidious * area))  # not used yet
            elif (LCF_tr == 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMP_sd) ** 2. / (LCF_bu * float(area)))  # Fix (fLCF_bu) issue #162
            elif (LCF_tr != 0 and LCF_bu == 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)))
            elif (LCF_tr != 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)) + float(IMP_sd) ** 2. / (LCF_bu * float(area)))

            pai = LCF_bu + LCF_ev + LCF_de
            
            # paiall = (planareaB + planareaV) / AT
            porosity = 0.2  # This should change with season. Net, set for Summer
            Pv = ((-1.251 * porosity ** 2) / 1.2) + ((0.489 * porosity) / 1.2) + (0.803 / 1.2)  # factor accounting for porosity to correct total fai in roughness calc Kent et al. 2017b
            # faiall_rgh = (frontalareaB + (Pv * frontalareaV)) / (AT / (1 / scale))  # frontal area used in roughness calculation Kent et al. 2017b
            fai = Pv * (float(IMPveg_fai_eve) + float(IMPveg_fai_dec)) + float(IMP_fai)
            if (fai == 0. and pai == 1.):
                IMP_z0 = 0.
                IMP_zd = zH
            elif (fai == 0. and pai < 1.):
                IMP_z0 = 0.
                IMP_zd = 0.
            else:
                IMP_zd, IMP_z0 = rg.RoughnessCalc("Kan", zH, fai, pai, zMax, sdComb)

            # clean up and give open country values if non-existant
            if np.isnan(IMP_z0) or IMP_z0 < 0.03:
                IMP_z0 = 0.03
            if np.isnan(IMP_zd) or IMP_zd < 0.2:
                IMP_zd = 0.2

            # # new for z (2017)
            try:
                z = ((float(IMP_heights_mean) * float(LCF_buildings) + float(IMPveg_heights_mean_eve) * float(LCF_evergreen) +
                    float(IMPveg_heights_mean_dec) * float(LCF_decidious)) / (float(LCF_buildings) + float(LCF_evergreen) + float(LCF_decidious))) * 3
            except:
                z = 10.
            if z < 10.:
                z = 10.

            if pop_density is not None:
                pop_density_night = feature.attribute(pop_density.currentField())
            else:
                pop_density_night = -999

            if daypop == 1:
                pop_density_day = feature.attribute(pop_density_day.currentField())
            else:
                pop_density_day = pop_density_night

            LUMPS_drate = 0.25
            LUMPS_Cover = 1
            LUMPS_MaxRes = 10
            NARP_Trans = 1

            flow_change = 0
            RunoffToWater = 0.1
            PipeCap = 100
            GridConn1of8 = 0
            Fraction1of8 = 0
            GridConn2of8 = 0
            Fraction2of8 = 0
            GridConn3of8 = 0
            Fraction3of8 = 0
            GridConn4of8 = 0
            Fraction4of8 = 0
            GridConn5of8 = 0
            Fraction5of8 = 0
            GridConn6of8 = 0
            Fraction6of8 = 0
            GridConn7of8 = 0
            Fraction7of8 = 0
            GridConn8of8 = 0
            Fraction8of8 = 0
    
            WhitinGridPav = 661
            WhitinGridBldg = 662
            WhitinGridEve = 663
            WhitinGridDec = 664
            WhitinGridGrass = 665
            WhitinGridUnmanBsoil = 666
            WhitinGridWaterCode = 667

            Fr_ESTMClass_Paved1 = 0.  ## Already in dict
            Fr_ESTMClass_Paved2 = 1.  ## Already in dict
            Fr_ESTMClass_Paved3 = 0.  ## Already in dict
            Code_ESTMClass_Paved1 = 99999  ## Already in dict
            Code_ESTMClass_Paved2 = 807  ## Already in dict
            Code_ESTMClass_Paved3 = 99999  ## Already in dict
            Fr_ESTMClass_Bldgs1 = 1.0  ## Already in dict
            Fr_ESTMClass_Bldgs2 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs3 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs4 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs5 = 0.  ## Already in dict
            Code_ESTMClass_Bldgs1 = 801  ## Already in dict
            Code_ESTMClass_Bldgs2 = 99999  ## Already in dict
            Code_ESTMClass_Bldgs3 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs4 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs5 = 99999 ## Already in dict

            SUEWS_param_dict ={
                # 
                "Year" : year,
                "StartDLS": start_DLS,
                "EndDLS" : end_DLS,
                # 'lat' : "set in code"
                # 'lon' : set in code
                "Timezone" : 0,
                "SurfaceArea" : hectare,
                'Alt' :  altitude,
                'id' : day,
                'ih': hour,
                "imin" : minute,
                # Fractions
                "Fr_Paved" : LCF_paved,
                "Fr_Bldgs" : LCF_buildings,
                "Fr_EveTr" : LCF_evergreen,
                "Fr_DecTr" : LCF_decidious,
                "Fr_Grass" : LCF_grass,
                "Fr_Bsoil" : LCF_baresoil,
                "Fr_Water" : LCF_water,
                # Irrigation Fraction
                "IrrFr_Paved" : IrrFr_Paved,
                "IrrFr_Bldgs" : IrrFr_Bldgs,
                "IrrFr_EveTr" : irrFr_EveTr,
                "IrrFr_DecTr" : irrFr_DecTr,
                "IrrFr_Grass" : irrFr_Grass,
                "IrrFr_BSoil" : IrrFr_BSoil,
                "IrrFr_Water" : IrrFr_Water,
                # Anthropoghenic Emis
                "QF0_BEU_WD" : QF0_BEU_WD,
                "QF0_BEU_WE" : QF0_BEU_WE,
                # Morphological params
                "H_Bldgs" : IMP_heights_mean,
                "H_EveTr" : IMPveg_heights_mean_eve,
                "H_DecTr" : IMPveg_heights_mean_dec,
                "z0" : '%.3f' % IMP_z0,
                "zd" : '%.3f' % IMP_zd,
                "z"  : '%.3f' % z,
                "FAI_Bldgs" : IMP_fai,
                "FAI_EveTr" : IMPveg_fai_eve,
                "FAI_DecTr" : IMPveg_fai_dec,
                "AreaWall" : (float(IMP_wai) * hectare * 10000.),
                "CondCode" : column_dict['Cnd'],
                "SnowCode" : snow_dict['Code'],
                'TrafficRate_WD' : column_dict['TrafficRate_WD'],
                'TrafficRate_WE' : column_dict['TrafficRate_WE'], 
                'SnowClearingProfWD' : column_dict['SnowClearingProfWD'], 
                'SnowClearingProfWE' : column_dict['SnowClearingProfWE'], 
                'AnthropogenicCode': column_dict['AnthropogenicCode'], 
                'IrrigationCode':  column_dict['IrrigationCode'], 
                'WaterUseProfManuWD': column_dict['WaterUseProfManuWD'], 
                'WaterUseProfManuWE': column_dict['WaterUseProfManuWE'], 
                'WaterUseProfAutoWD': column_dict['WaterUseProfAutoWD'], 
                'WaterUseProfAutoWE' : column_dict['WaterUseProfAutoWE'], 
                # Population
                "PopDensDay" : '%.3f' % pop_density_day,
                "PopDensNight" : '%.3f' % pop_density_night,
                # Lumps Narp
                "LUMPS_DrRate" : LUMPS_drate,
                "LUMPS_Cover"  : LUMPS_Cover,
                "LUMPS_MaxRes" : LUMPS_MaxRes,
                "NARP_Trans" : NARP_Trans,
                # Water Flow 
                "FlowChange" : flow_change,
                "RunoffToWater" : RunoffToWater,
                "PipeCapacity" : PipeCap,
                "GridConnection1of8" : GridConn1of8,
                "GridConnection2of8" : GridConn2of8,
                "GridConnection3of8" : GridConn3of8,
                "GridConnection4of8" : GridConn4of8,
                "GridConnection5of8" : GridConn5of8,
                "GridConnection6of8" : GridConn6of8,
                "GridConnection7of8" : GridConn7of8,
                "GridConnection8of8" : GridConn8of8,
                "Fraction1of8" : Fraction1of8,
                "Fraction2of8" : Fraction2of8,
                "Fraction3of8" : Fraction3of8,
                "Fraction4of8" : Fraction4of8,
                "Fraction5of8" : Fraction5of8,
                "Fraction6of8" : Fraction6of8,
                "Fraction7of8" : Fraction7of8,
                "Fraction8of8" : Fraction8of8,
                "WithinGridPavedCode" : WhitinGridPav,
                "WithinGridBldgsCode" : WhitinGridBldg,
                "WithinGridEveTrCode" : WhitinGridEve,
                "WithinGridDecTrCode" : WhitinGridDec,
                "WithinGridGrassCode" : WhitinGridGrass,
                "WithinGridUnmanBSoilCode" : WhitinGridUnmanBsoil,
                "WithinGridWaterCode" : WhitinGridWaterCode,

                # ESTM OLD
                "Fr_ESTMClass_Bldgs1": Fr_ESTMClass_Bldgs1,
                "Fr_ESTMClass_Bldgs2": Fr_ESTMClass_Bldgs2,
                "Fr_ESTMClass_Bldgs3": Fr_ESTMClass_Bldgs3,
                "Fr_ESTMClass_Bldgs4": Fr_ESTMClass_Bldgs4,
                "Fr_ESTMClass_Bldgs5": Fr_ESTMClass_Bldgs5,
                "Fr_ESTMClass_Paved1": Fr_ESTMClass_Paved1,
                "Fr_ESTMClass_Paved2": Fr_ESTMClass_Paved2,
                "Fr_ESTMClass_Paved3": Fr_ESTMClass_Paved3,
                "Code_ESTMClass_Bldgs1": Code_ESTMClass_Bldgs1,
                "Code_ESTMClass_Bldgs2": Code_ESTMClass_Bldgs2,
                "Code_ESTMClass_Bldgs3": Code_ESTMClass_Bldgs3,
                "Code_ESTMClass_Bldgs4": Code_ESTMClass_Bldgs4,
                "Code_ESTMClass_Bldgs5": Code_ESTMClass_Bldgs5,
                "Code_ESTMClass_Paved1": Code_ESTMClass_Paved1,
                "Code_ESTMClass_Paved2": Code_ESTMClass_Paved2,
                "Code_ESTMClass_Paved3": Code_ESTMClass_Paved3,  
            }

            for code in SUEWS_param_dict.keys():
                ss_dict[feat_id][code] = str(SUEWS_param_dict[code])

        ss_txt_p = plugin_dir +'/Input/SUEWS_SiteSelect.txt' # TODO Fix to set path wihtin UMEP Toolbox
        save_SiteSelect(ss_dict, save_txt_folder, ss_txt_p)

        init_out = output_dir[0] + '/InitialConditions' + str(file_code) + '_' + str(year) + '.nml'
        self.write_to_init(plugin_dir + '/Input/' + 'InitialConditions.nml', init_out)

        # Response to issue #462. Should change in future versions
        copyfile(plugin_dir + '/Input/' + 'ESTMinput.nml', output_dir[0] + "/" + 'ESTMinput.nml')
        copyfile(plugin_dir + '/Input/' + 'GridLayoutKc.nml', output_dir[0] + "/" + 'GridLayout' + str(file_code) + '.nml')

        copyfile(plugin_dir + '/Input/' + 'SUEWS_SPARTACUS.nml', output_dir[0] + "/" + 'SUEWS_SPARTACUS.nml')
        # TODO Fix withinGridWaterDist
        copyfile(plugin_dir + '/Input/' + 'SUEWS_WithinGridWaterDist.txt', output_dir[0] + "/" + 'WithinGridWaterDist.txt')




##########################################################################################

        # for feature in self.vlayer.getFeatures():
        #     if self.killed is True:
        #         break
        #     # new_line = [None] * (len(self.nbr_header) - 3)
        #     print_line = True
        #     feat_id = int(feature.attribute(self.poly_field))
        #     ss_dict={} 
        #     ss_dict['Grid'] = str(feat_id)
        #     # code = "Grid"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(feat_id)
        #     print('Processing ID: ' + str(feat_id))   
        #     year = None
        #     year2 = None

        #     if self.Metfile_path is None:
        #         QMessageBox.critical(None, "Error", "Meteorological data file has not been provided,"
        #                                             " please check the main tab")
        #         return
        #     elif os.path.isfile(self.Metfile_path[0]):
        #         with open(self.Metfile_path[0]) as file:
        #             next(file)
        #             for line in file:
        #                 split = line.split()
        #                 if year == split[0]:
        #                     break
        #                 else:
        #                     if year2 == split[0]:
        #                         year = split[0]
        #                         break
        #                     elif year is None:
        #                         year = split[0]
        #                     else:
        #                         year2 = split[0]

        #         # figure out the time res of input file
        #         if ind == 1:
        #             met_old = np.genfromtxt(self.Metfile_path[0], skip_header=1, skip_footer=2)
        #             id = met_old[:, 1]
        #             it = met_old[:, 2]
        #             imin = met_old[:, 3]
        #             dectime0 = id[0] + it[0] / 24 + imin[0] / (60 * 24)
        #             dectime1 = id[1] + it[1] / 24 + imin[1] / (60 * 24)
        #             res = int(np.round((dectime1 - dectime0) * (60 * 24)))
        #             ind = 999

        #     else:
        #         QMessageBox.critical(None, "Error",
        #                                 "Could not find the file containing meteorological data")
        #         return

        #     code = "Year"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(year)
        #     ss_dict[code] = str(year)

        #     code = "StartDLS"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(self.start_DLS)
        #     ss_dict[code] = str(str(self.start_DLS))

        #     code = "EndDLS"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(self.end_DLS)
        #     ss_dict[code] = str(str(self.end_DLS))


        #     old_cs = osr.SpatialReference()
        #     vlayer_ref = self.vlayer.crs().toWkt()
        #     old_cs.ImportFromWkt(vlayer_ref)

        #     wgs84_wkt = """
        #     GEOGCS["WGS 84",
        #         DATUM["WGS_1984",
        #             SPHEROID["WGS 84",6378137,298.257223563,
        #                 AUTHORITY["EPSG","7030"]],
        #             AUTHORITY["EPSG","6326"]],
        #         PRIMEM["Greenwich",0,
        #             AUTHORITY["EPSG","8901"]],
        #         UNIT["degree",0.01745329251994328,
        #             AUTHORITY["EPSG","9122"]],
        #         AUTHORITY["EPSG","4326"]]"""

        #     new_cs = osr.SpatialReference()
        #     new_cs.ImportFromWkt(wgs84_wkt)

        #     transform = osr.CoordinateTransformation(old_cs, new_cs)

        #     centroid = feature.geometry().centroid().asPoint()
        #     area = feature.geometry().area()

        #     if self.map_units == 0:
        #         hectare = area * 0.0001 # meter

        #     elif self.map_units == 1:
        #         hectare = area / 107640. # square foot

        #     else:
        #         hectare = area
        #     gdalver = float(gdal.__version__[0])
        #     lonlat = transform.TransformPoint(centroid.x(), centroid.y())
        #     code = "lat"
        #     # index = self.find_index(code)
        #     if gdalver == 3.:
        #         # new_line[index] = '%.6f' % lonlat[0] #changed to gdal 3
        #         ss_dict[code] =  '%.6f' % lonlat[0] #changed to gdal 3
        #     else:
        #         # new_line[index] = '%.6f' % lonlat[1] #changed to gdal 2
        #         ss_dict[code] =  '%.6f' % lonlat[1] #changed to gdal 3

        #     code = "lng"
        #     # index = self.find_index(code)
        #     if gdalver == 3.:
        #         # new_line[index] = '%.6f' % lonlat[1] #changed to gdal 3
        #         ss_dict[code] =  '%.6f' % lonlat[1] #changed to gdal 3
        #     else:
        #         # new_line[index] = '%.6f' % lonlat[0] #changed to gdal 2
        #         ss_dict[code] =  '%.6f' % lonlat[0] #changed to gdal 3


        #     code = "Timezone"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(self.utc)
        
        #     ss_dict[code] = str(self.utc)
        #     code = "SurfaceArea"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(hectare)
        #     ss_dict[code] = str(hectare)
 
        #     altitude = 0
        #     day = 1
        #     hour = 0
        #     minute = 0

        #     code = "Alt"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(altitude)
        #     ss_dict[code] =  str(altitude) #changed to gdal 3
        #     code = "id"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(day)
        #     ss_dict[code] = str(day)
        #     code = "ih"
        #     ss_dict[code] = str(hour)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(hour)
        #     code = "imin"
        #     ss_dict[code] = str(minute)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(minute)

        #     if self.LCF_from_file:
        #         found_LCF_line = False
        #         with open(self.LCFfile_path[0]) as file:
        #             next(file)
        #             for line in file:
        #                 split = line.split()
        #                 if feat_id == int(split[0]):
        #                     LCF_paved = split[1]
        #                     LCF_buildings = split[2]
        #                     LCF_evergreen = split[3]
        #                     LCF_decidious = split[4]
        #                     LCF_grass = split[5]
        #                     LCF_baresoil = split[6]
        #                     LCF_water = split[7]
        #                     found_LCF_line = True
        #                     break
        #             if not found_LCF_line:
        #                 LCF_paved = -999
        #                 LCF_buildings = -999
        #                 LCF_evergreen = -999
        #                 LCF_decidious = -999
        #                 LCF_grass = -999
        #                 LCF_baresoil = -999
        #                 LCF_water = -999
        #                 print_line = False

        #     else:
        #         LCF_paved = feature.attribute(self.LCF_paved.getFieldName())
        #         LCF_buildings = feature.attribute(self.LCF_buildings.getFieldName())
        #         LCF_evergreen = feature.attribute(self.LCF_evergreen.getFieldName())
        #         LCF_decidious = feature.attribute(self.LCF_decidious.getFieldName())
        #         LCF_grass = feature.attribute(self.LCF_grass.getFieldName())
        #         LCF_baresoil = feature.attribute(self.LCF_baresoil.getFieldName())
        #         LCF_water = feature.attribute(self.LCF_water.getFieldName())

        #     code = "Fr_Paved"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_paved)
        #     ss_dict[code] = str(LCF_paved)
        #     code = "Fr_Bldgs"
        #     ss_dict[code] = str(LCF_buildings)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_buildings)
        #     code = "Fr_EveTr"
        #     ss_dict[code] = str(LCF_buildings)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_evergreen)
        #     code = "Fr_DecTr"
        #     ss_dict[code] = str(LCF_decidious)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_decidious)
        #     code = "Fr_Grass"
        #     ss_dict[code] = str(LCF_grass)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_grass)
        #     code = "Fr_Bsoil"
        #     ss_dict[code] = str(LCF_baresoil)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_baresoil)
        #     code = "Fr_Water"
        #     ss_dict[code] = str(LCF_water)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LCF_water)

        #     irrFr_EveTr = 0
        #     irrFr_DecTr = 0
        #     irrFr_Grass = 0
        #     IrrFr_Bldgs = 0
        #     IrrFr_Paved = 0
        #     IrrFr_Water = 0
        #     IrrFr_BSoil = 0

        #     code = "IrrFr_EveTr"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(irrFr_EveTr)
        #     ss_dict[code] = str(irrFr_EveTr)
        #     code = "IrrFr_DecTr"
        #     ss_dict[code] = str(irrFr_DecTr)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(irrFr_DecTr)
        #     code = "IrrFr_Grass"
        #     ss_dict[code] = str(irrFr_Grass)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(irrFr_Grass)
        #     code = "IrrFr_Bldgs"
        #     ss_dict[code] = str(IrrFr_Bldgs)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IrrFr_Bldgs)
        #     code = "IrrFr_Paved"
        #     ss_dict[code] = str(IrrFr_Paved)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IrrFr_Paved)
        #     code = "IrrFr_Water"
        #     ss_dict[code] = str(IrrFr_Water)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IrrFr_Water)
        #     code = "IrrFr_BSoil"
        #     ss_dict[code] = str(IrrFr_BSoil)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IrrFr_BSoil)

        #     TrafficRate_WD = 0.01
        #     TrafficRate_WE = 0.01
        #     code = "TrafficRate_WD"
        #     ss_dict[code] = str(TrafficRate_WD)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(TrafficRate_WD)
        #     code = "TrafficRate_WE"
        #     ss_dict[code] = str(TrafficRate_WE)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(TrafficRate_WE)

        #     QF0_BEU_WD = 0.88
        #     QF0_BEU_WE = 0.88
        #     code = "QF0_BEU_WD"
        #     ss_dict[code] = str(QF0_BEU_WD)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(QF0_BEU_WD)
        #     code = "QF0_BEU_WE"
        #     ss_dict[code] = str(QF0_BEU_WE)            
        #     # index = self.find_index(code)
        #     # new_line[index] = str(QF0_BEU_WE)

        #     # Activity_ProfWD = 55663
        #     # Activity_ProfWE = 55664
        #     #
        #     # code = "ActivityProfWD"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Activity_ProfWD)
        #     # code = "ActivityProfWE"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Activity_ProfWE)

        #     if self.IMP_from_file:
        #         found_IMP_line = False

        #         with open(self.IMPfile_path[0]) as file:
        #             next(file)
        #             for line in file:
        #                 split = line.split()
        #                 if feat_id == int(split[0]):
        #                     IMP_heights_mean = split[3]
        #                     IMP_z0 = split[6]
        #                     IMP_zd = split[7]
        #                     IMP_fai = split[2]
        #                     IMP_max = split[4]
        #                     IMP_sd = split[5]
        #                     IMP_wai = split[8]
        #                     found_IMP_line = True
        #                     break
        #             if not found_IMP_line:
        #                 IMP_heights_mean = -999
        #                 IMP_z0 = -999
        #                 IMP_zd = -999
        #                 IMP_fai = -999
        #                 IMP_wai = -999
        #                 print_line = False
        #     else:
        #         IMP_heights_mean = feature.attribute(self.IMP_mean_height.getFieldName())
        #         IMP_z0 = feature.attribute(self.IMP_z0.getFieldName())
        #         IMP_zd = feature.attribute(self.IMP_zd.getFieldName())
        #         IMP_fai = feature.attribute(self.IMP_fai.getFieldName())
        #         IMP_wai = feature.attribute(self.IMP_wai.getFieldName())

        #     if self.IMPveg_from_file:
        #         found_IMPveg_line = False

        #         with open(self.IMPvegfile_path[0]) as file:
        #             next(file)
        #             for line in file:
        #                 split = line.split()
        #                 if feat_id == int(split[0]):
        #                     IMPveg_heights_mean_eve = split[3]
        #                     IMPveg_heights_mean_dec = split[3]
        #                     IMPveg_fai_eve = split[2]
        #                     IMPveg_fai_dec = split[2]
        #                     IMPveg_max_eve = split[4]  #TODO not used yet
        #                     IMPveg_sd_eve = split[5]  #TODO not used yet
        #                     IMPveg_max_dec = split[4]
        #                     IMPveg_sd_dec = split[5]
        #                     found_IMPveg_line = True
        #                     break
        #             if not found_IMPveg_line:
        #                 IMPveg_heights_mean_eve = -999
        #                 IMPveg_heights_mean_dec = -999
        #                 IMPveg_fai_eve = -999
        #                 IMPveg_fai_dec = -999
        #                 print_line = False
        #     else:
        #         IMPveg_heights_mean_eve = feature.attribute(self.IMPveg_mean_height_eve.getFieldName())
        #         IMPveg_heights_mean_dec = feature.attribute(self.IMPveg_mean_height_dec.getFieldName())
        #         IMPveg_fai_eve = feature.attribute(self.IMPveg_fai_eve.getFieldName())
        #         IMPveg_fai_dec = feature.attribute(self.IMPveg_fai_dec.getFieldName())

        #     code = "H_Bldgs"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMP_heights_mean)
        #     ss_dict[code] = str(IMP_heights_mean)
        #     code = "H_EveTr"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMPveg_heights_mean_eve)
        #     ss_dict[code] = str(IMPveg_heights_mean_eve)

        #     code = "H_DecTr"
        #     ss_dict[code] = str(IMPveg_heights_mean_dec)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMPveg_heights_mean_dec)

        #     # New calcualtion of rouhgness params v2017 (Kent et al. 2017b)
        #     # Evergreen not yet included in the calculations
        #     LCF_de = float(LCF_decidious)
        #     LCF_ev = float(LCF_evergreen)
        #     LCF_bu = float(LCF_buildings)
        #     LCF_tr = LCF_de + LCF_ev # temporary fix while ev and de is not separated, issue 155
        #     if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
        #         zH = 0
        #         zMAx = 0
        #     else:
        #         zH = (float(IMP_heights_mean) * LCF_bu + float(IMPveg_heights_mean_eve) * LCF_ev + float(IMPveg_heights_mean_dec) * LCF_de) / (LCF_bu + LCF_ev + LCF_de)                    
        #         zMax = max(float(IMPveg_max_dec),float(IMP_max))

        #     if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
        #         sdComb = 0
        #         IMP_z0 = 0
        #         IMP_zd = 0
        #         # sdTree = np.sqrt((IMPveg_sd_eve ^ 2 / LCF_evergreen * area) + (IMPveg_sd_dec ^ 2 / LCF_decidious * area))  # not used yet
        #     elif (LCF_tr == 0 and LCF_bu != 0):
        #         sdComb = np.sqrt(float(IMP_sd) ** 2. / (LCF_bu * float(area)))  # Fix (fLCF_bu) issue #162
        #     elif (LCF_tr != 0 and LCF_bu == 0):
        #         sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)))
        #     elif (LCF_tr != 0 and LCF_bu != 0):
        #         sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)) + float(IMP_sd) ** 2. / (LCF_bu * float(area)))

        #     pai = LCF_bu + LCF_ev + LCF_de
            
        #     # paiall = (planareaB + planareaV) / AT
        #     porosity = 0.2  # This should change with season. Net, set for Summer
        #     Pv = ((-1.251 * porosity ** 2) / 1.2) + ((0.489 * porosity) / 1.2) + (0.803 / 1.2)  # factor accounting for porosity to correct total fai in roughness calc Kent et al. 2017b
        #     # faiall_rgh = (frontalareaB + (Pv * frontalareaV)) / (AT / (1 / scale))  # frontal area used in roughness calculation Kent et al. 2017b
        #     fai = Pv * (float(IMPveg_fai_eve) + float(IMPveg_fai_dec)) + float(IMP_fai)
        #     if (fai == 0. and pai == 1.):
        #         IMP_z0 = 0.
        #         IMP_zd = zH
        #     elif (fai == 0. and pai < 1.):
        #         IMP_z0 = 0.
        #         IMP_zd = 0.
        #     else:
        #         IMP_zd, IMP_z0 = rg.RoughnessCalc("Kan", zH, fai, pai, zMax, sdComb)

        #     # clean up and give open country values if non-existant
        #     if np.isnan(IMP_z0) or IMP_z0 < 0.03:
        #         IMP_z0 = 0.03
        #     if np.isnan(IMP_zd) or IMP_zd < 0.2:
        #         IMP_zd = 0.2

        #     code = "z0"
        #     ss_dict[code] =  '%.3f' % IMP_z0
        #     # index = self.find_index(code)
        #     # new_line[index] = '%.3f' % IMP_z0
        #     code = "zd"
        #     ss_dict[code] = '%.3f' % IMP_zd
        #     # index = self.find_i'ndex(code)
        #     # new_line[index] = ''%.3f' % IMP_zd
        #     code = "FAI_Bldgs"
        #     ss_dict[code] = str(IMP_fai)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMP_fai)
        #     code = "FAI_EveTr"
        #     ss_dict[code] = IMPveg_fai_eve
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMPveg_fai_eve)
        #     code = "FAI_DecTr"
        #     ss_dict[code] = IMPveg_fai_dec
        #     # index = self.find_index(code)
        #     # new_line[index] = str(IMPveg_fai_dec)

        #     # new for z (2017)
        #     code = "z"
        #     # index = self.find_index(code)
        #     try:
        #         z = ((float(IMP_heights_mean) * float(LCF_buildings) + float(IMPveg_heights_mean_eve) * float(LCF_evergreen) +
        #             float(IMPveg_heights_mean_dec) * float(LCF_decidious)) / (float(LCF_buildings) + float(LCF_evergreen) + float(LCF_decidious))) * 3
        #     except:
        #         z = 10.
        #     if z < 10.:
        #         z = 10.

        #     ss_dict[code] = '%.3f' % z
        #     # new_line[index] = '%.3f' % z

        #     if self.pop_density is not None:
        #         pop_density_night = feature.attribute(self.pop_density.currentField())
        #     else:
        #         pop_density_night = -999

        #     if self.daypop == 1:
        #         pop_density_day = feature.attribute(self.pop_density_day.currentField())
        #     else:
        #         pop_density_day = pop_density_night
        #     code = "PopDensDay"
        #     # index = self.find_index(code)
        #     # new_line[index] = '%.3f' % pop_density_day
        #     ss_dict[code] = '%.3f' % pop_density_day
        #     code = "PopDensNight"
        #     ss_dict[code] = '%.3f' % pop_density_night
        #     # index = self.find_index(code)
        #     # new_line[index] = '%.3f' % pop_density_night
        #     # for widget in self.widget_list:
        #     #     if widget.get_checkstate():
        #     #         code_field = str(widget.comboBox_uniquecodes.currentText())
        #     #         try:
        #     #             code = int(feature.attribute(code_field))
        #     #         except ValueError as e:
        #     #             QMessageBox.critical(None, "Error",
        #     #                                     "Unique code field for widget " + widget.get_title() +
        #     #                                     " should only contain integers")
        #     #             return
        #     #         match = widget.comboBox.findText(str(code))
        #     #         if match == -1:
        #     #             QMessageBox.critical(None, "Error",
        #     #                                     "Unique code field for widget " + widget.get_title() +
        #     #                                     " contains one or more codes with no match in site library")
        #     #             return
        #     #         index = widget.get_sitelistpos()
        #     #         # new_line[index - 1] = str(code)

        #     #     else:
        #     #         code = widget.get_combo_text()
        #     #         index = widget.get_sitelistpos()
        #     #         # new_line[index - 1] = str(code)

        #     LUMPS_drate = 0.25
        #     LUMPS_Cover = 1
        #     LUMPS_MaxRes = 10
        #     NARP_Trans = 1
        #     code = "LUMPS_DrRate"
        #     ss_dict[code] = str(LUMPS_drate)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LUMPS_drate)
        #     code = "LUMPS_Cover"
        #     ss_dict[code] = str(LUMPS_Cover)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LUMPS_Cover)
        #     code = "LUMPS_MaxRes"
        #     ss_dict[code] = str(LUMPS_MaxRes)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(LUMPS_MaxRes)
        #     code = "NARP_Trans"
        #     ss_dict[code] = str(NARP_Trans)
        #     # index = self.find_index(code)
        #     # new_line[index] = str(NARP_Trans)

        #     flow_change = 0
        #     RunoffToWater = 0.1
        #     PipeCap = 100
        #     GridConn1of8 = 0
        #     Fraction1of8 = 0
        #     GridConn2of8 = 0
        #     Fraction2of8 = 0
        #     GridConn3of8 = 0
        #     Fraction3of8 = 0
        #     GridConn4of8 = 0
        #     Fraction4of8 = 0
        #     GridConn5of8 = 0
        #     Fraction5of8 = 0
        #     GridConn6of8 = 0
        #     Fraction6of8 = 0
        #     GridConn7of8 = 0
        #     Fraction7of8 = 0
        #     GridConn8of8 = 0
        #     Fraction8of8 = 0
    
        #     # code = "FlowChange"

        #     # # index = self.find_index(code)
        #     # # new_line[index] = str(flow_change)
        #     # code = "RunoffToWater"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(RunoffToWater)
        #     # code = "PipeCapacity"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(PipeCap)
        #     # code = "GridConnection1of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn1of8)
        #     # code = "Fraction1of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction1of8)
        #     # code = "GridConnection2of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn2of8)
        #     # code = "Fraction2of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction2of8)
        #     # code = "GridConnection3of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn3of8)
        #     # code = "Fraction3of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction3of8)
        #     # code = "GridConnection4of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn4of8)
        #     # code = "Fraction4of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction4of8)
        #     # code = "GridConnection5of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn5of8)
        #     # code = "Fraction5of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction5of8)
        #     # code = "GridConnection6of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn6of8)
        #     # code = "Fraction6of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction6of8)
        #     # code = "GridConnection7of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn7of8)
        #     # code = "Fraction7of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction7of8)
        #     # code = "GridConnection8of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(GridConn8of8)
        #     # code = "Fraction8of8"
        #     # index = self.find_index(code)
        #     # new_line[index] = str(Fraction8of8)

        #     WhitinGridPav = 661
        #     WhitinGridBldg = 662
        #     WhitinGridEve = 663
        #     WhitinGridDec = 664
        #     WhitinGridGrass = 665
        #     WhitinGridUnmanBsoil = 666
        #     WhitinGridWaterCode = 667

        #     flow_dict = {
        #         'FlowChange' : str(RunoffToWater),
        #         "PipeCapacity" : str(PipeCap),
        #         "GridConnection1of8" : str(GridConn1of8),
        #         "GridConnection2of8" : str(GridConn2of8),
        #         "GridConnection3of8" : str(GridConn3of8),
        #         "GridConnection4of8" : str(GridConn4of8),
        #         "GridConnection5of8" : str(GridConn5of8),
        #         "GridConnection6of8" : str(GridConn6of8),
        #         "GridConnection7of8" : str(GridConn7of8),
        #         "GridConnection8of8" : str(GridConn8of8),
        #         "Fraction1of8" : str(Fraction1of8),
        #         "Fraction2of8" : str(Fraction1of8),
        #         "Fraction3of8" : str(Fraction1of8),
        #         "Fraction4of8" : str(Fraction1of8),
        #         "Fraction5of8" : str(Fraction1of8),
        #         "Fraction6of8" : str(Fraction1of8),
        #         "Fraction7of8" : str(Fraction1of8),
        #         "Fraction8of8" : str(Fraction1of8),
        #         'WithinGridPavedCode' : str(WhitinGridPav),
        #         'WithinGridBldgsCode' : str(WhitinGridBldg),
        #         'WithinGridEveTrCode' : str(WhitinGridEve),
        #         'WithinGridDecTrCode' : str(WhitinGridDec),
        #         'WithinGridGrassCode' : str(WhitinGridGrass),
        #         'WithinGridUnmanBSoilCode' : str(WhitinGridUnmanBsoil),
        #         'WithinGridWaterCode' : str(WhitinGridWaterCode),
        #     } 

        #     for code in flow_dict.keys():
        #         ss_dict[code] = flow_dict[code]

            # code = "WithinGridPavedCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridPav)
            # code = "WithinGridBldgsCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridBldg)
            # code = "WithinGridEveTrCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridEve)
            # code = "WithinGridDecTrCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridDec)
            # code = "WithinGridGrassCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridGrass)
            # code = "WithinGridUnmanBSoilCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridUnmanBsoil)
            # code = "WithinGridWaterCode"
            # index = self.find_index(code)
            # new_line[index] = str(WhitinGridWaterCode)



            # if self.wall_area_info:
            #     wall_area = feature.attribute(self.wall_area.getFieldName())
            # else:
            #     wall_area = -999

            # code = "AreaWall"
            # ss_dict[code] = str(float(IMP_wai) * hectare * 10000.)
            # index = self.find_index(code)
            # new_line[index] = str(float(IMP_wai) * hectare * 10000.) # currently wallarea. Will change to wai

            

            # if self.land_use_from_file:
            #     with open(self.land_use_file_path[0]) as file:
            #         next(file)
            #         found_LUF_line = False
            #         for line in file:
            #             split = line.split()
            #             if feat_id == int(split[0]):
            #                 Fr_ESTMClass_Paved1 = split[1]
            #                 Fr_ESTMClass_Paved2 = split[2]
            #                 Fr_ESTMClass_Paved3 = split[3]
            #                 if (float(Fr_ESTMClass_Paved1) == 0 and float(Fr_ESTMClass_Paved2) == 0 and float(Fr_ESTMClass_Paved3) == 0):
            #                     Fr_ESTMClass_Paved2 = 1.0
            #                 Code_ESTMClass_Paved1 = split[4]
            #                 Code_ESTMClass_Paved2 = split[5]
            #                 Code_ESTMClass_Paved3 = split[6]
            #                 Fr_ESTMClass_Bldgs1 = split[7]
            #                 Fr_ESTMClass_Bldgs2 = split[8]
            #                 Fr_ESTMClass_Bldgs3 = split[9]
            #                 Fr_ESTMClass_Bldgs4 = split[10]
            #                 Fr_ESTMClass_Bldgs5 = split[11]
            #                 if (float(Fr_ESTMClass_Bldgs1) == 0 and float(Fr_ESTMClass_Bldgs2) == 0 and float(Fr_ESTMClass_Bldgs3) == 0 and float(Fr_ESTMClass_Bldgs4) == 0 and float(Fr_ESTMClass_Bldgs5) == 0):
            #                     Fr_ESTMClass_Bldgs3 = 1.0
            #                 Code_ESTMClass_Bldgs1 = split[12]
            #                 Code_ESTMClass_Bldgs2 = split[13]
            #                 Code_ESTMClass_Bldgs3 = split[14]
            #                 Code_ESTMClass_Bldgs4 = split[15]
            #                 Code_ESTMClass_Bldgs5 = split[16]

            #                 # if (float(Fr_ESTMClass_Paved1) + float(Fr_ESTMClass_Paved2) + float(Fr_ESTMClass_Paved3)) != 1:
            #                 #     QMessageBox.critical(None, "Error", "Land use fractions for paved not equal to 1 at " + str(feat_id))
            #                 #     return
            #                 #
            #                 # if (float(Fr_ESTMClass_Bldgs1) + float(Fr_ESTMClass_Bldgs2) + float(Fr_ESTMClass_Bldgs3) + float(Fr_ESTMClass_Bldgs4) + float(Fr_ESTMClass_Bldgs5)) != 1:
            #                 #     QMessageBox.critical(None, "Error", "Land use fractions for buildings not equal to 1 at " + str(feat_id))
            #                 #     return

            #                 found_LUF_line = True
            #                 break

            # for code in estm_dict.keys():
            #     ss_dict[code] = estm_dict[code]

        

            # code = "Fr_ESTMClass_Bldgs1"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Bldgs1)
            # code = "Fr_ESTMClass_Bldgs2"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Bldgs2)
            # code = "Fr_ESTMClass_Bldgs3"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Bldgs3)
            # code = "Fr_ESTMClass_Bldgs4"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Bldgs4)
            # code = "Fr_ESTMClass_Bldgs5"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Bldgs5)
            # code = "Fr_ESTMClass_Paved1"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Paved1)
            # code = "Fr_ESTMClass_Paved2"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Paved2)
            # code = "Fr_ESTMClass_Paved3"
            # index = self.find_index(code)
            # new_line[index] = str(Fr_ESTMClass_Paved3)
            # code = "Code_ESTMClass_Bldgs1"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Bldgs1)
            # code = "Code_ESTMClass_Bldgs2"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Bldgs2)
            # code = "Code_ESTMClass_Bldgs3"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Bldgs3)
            # code = "Code_ESTMClass_Bldgs4"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Bldgs4)
            # code = "Code_ESTMClass_Bldgs5"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Bldgs5)
            # code = "Code_ESTMClass_Paved1"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Paved1)
            # code = "Code_ESTMClass_Paved2"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Paved2)
            # code = "Code_ESTMClass_Paved3"
            # index = self.find_index(code)
            # new_line[index] = str(Code_ESTMClass_Paved3)

        #     new_line.append("!")

        #     if print_line:
        #         self.lines_to_write.append(new_line)

        #     # self.progress.emit()

        # # Writing met files and add lines in SIteSelect if multiple years
        # met_in = np.genfromtxt(self.Metfile_path[0], skip_header=1)

        # YYYYmin = np.min(met_in[:, 0])
        # YYYYmax = np.max(met_in[:, 0])
        # addrows = 0

        # # check if full year
        # if YYYYmin < YYYYmax:
        #     t = np.where(met_in[:, 0] == YYYYmax)
        #     if not t.__len__() > 1:
        #         # YYYYmax = YYYYmin
        #         YYYYmax = YYYYmax - 1  # Issue #65

        # lensiteselect = self.lines_to_write.__len__() - 2
        # for YYYY in range(int(YYYYmin), int(YYYYmax) + 1):
        #     # find start end end of 5 min file for each year
        #     if res == 60:
        #         posstart = np.where((met_in[:, 0] == YYYY) & (met_in[:, 1] == 1) & (met_in[:, 2] == 1) & (met_in[:, 3] == 0))
        #     elif res == 120:
        #         posstart = np.where((met_in[:, 0] == YYYY) & (met_in[:, 1] == 1) & (met_in[:, 2] == 2) & (met_in[:, 3] == 0))
        #     elif res == 180:
        #         posstart = np.where((met_in[:, 0] == YYYY) & (met_in[:, 1] == 1) & (met_in[:, 2] == 3) & (met_in[:, 3] == 0))
        #     else:
        #         posstart = np.where((met_in[:, 0] == YYYY) & (met_in[:, 1] == 1) & (met_in[:, 2] == 0) & (met_in[:, 3] == res))

        #     posend = np.where((met_in[:, 0] == (YYYY + 1)) & (met_in[:, 1] == 1) & (met_in[:, 2] == 0) & (met_in[:, 3] == 0))
        #     fixpos = 1

        #     if len(posstart[0]) == 0:
        #         starting = 0
        #     else:
        #         starting = posstart[0]
        #     if len(posend[0]) == 0:
        #         ending = met_in.shape[0]
        #         fixpos = 0
        #     else:
        #         ending = posend[0]

        #     met_save = met_in[int(starting):int(ending) + fixpos, :]  # originally for one full year

        #     # --- save met-file --- #
        #     data_out = self.output_dir[0] + "/" + self.file_code + '_' + str(YYYY) + '_data_' + str(res) + '.txt'
        #     header = '%iy id it imin Q* QH QE Qs Qf Wind RH Td press rain Kdn snow ldown fcld wuh xsmd lai_hr ' \
        #                 'Kdiff Kdir Wd'
        #     numformat = '%3d %2d %3d %2d %6.2f %6.2f %6.2f %6.2f %6.2f %6.2f %6.2f %6.2f %6.2f %6.4f %6.2f %6.2f ' \
        #                 '%6.2f %6.2f %6.4f %6.2f %6.2f %6.2f %6.2f %6.2f'

        #     np.savetxt(data_out, met_save, fmt=numformat, delimiter=' ', header=header, comments='')

        #     # Add new year in SiteSelect
        #     if addrows > 0:
        #         for i in range(0, lensiteselect):
        #             lines_to_write_oneyear = copy.copy(self.lines_to_write[i+2])
        #             lines_to_write_oneyear[1] = str(YYYY)
        #             self.lines_to_write.append(lines_to_write_oneyear)
        #     addrows += 1

        # init_out = self.output_dir[0] + '/InitialConditions' + str(self.file_code) + '_' + str(year) + '.nml'
        # self.write_to_init(self.input_path + 'InitialConditions.nml', init_out)

        # output_lines = []
        # output_file = self.output_dir[0] + "/SUEWS_SiteSelect.txt"
        # with open(output_file, 'w+') as ofile:
        #     for line in self.lines_to_write:
        #         string_to_print = ''
        #         for element in line:
        #             string_to_print += str(element) + '\t'
        #         string_to_print += "\n"s
        #         output_lines.append(string_to_print)
        #     output_lines.append("-9\n")
        #     output_lines.append("-9\n")
        #     ofile.writelines(output_lines)
        #     for input_file in self.output_file_list:
        #         try:
        #             print("Copied: " + self.output_dir[0] + "/" + input_file)
        #             copyfile(self.output_path + input_file, self.output_dir[0] + "/" + input_file)
        #         except IOError as e:
        #             QgsMessageLog.logMessage(
        #                 "Error copying output files with SUEWS_SiteSelect.txt: " + str(e),
        #                 level=Qgis.Critical)

    # def find_index(self, code):
    #     values = self.header_sheet.row_values(1)
    #     index = values.index(code)
    #     return index
    
    def write_to_init(self, initfilein, initfileout):
        LeafCycle = self.leaf_cycle
        SoilMoisture = self.soil_moisture
        moist = int(SoilMoisture * 1.5)
        snowinitially = 0

        nml = f90nml.read(initfilein)

        nml['initialconditions']['soilstorepavedstate'] = moist
        nml['initialconditions']['soilstorebldgsstate'] = moist
        nml['initialconditions']['soilstoreevetrstate'] = moist
        nml['initialconditions']['soilstoredectrstate'] = moist
        nml['initialconditions']['soilstoregrassstate'] = moist
        nml['initialconditions']['soilstorebsoilstate'] = moist

        # Based on London data
        if LeafCycle == 1:  # Winter
            nml['initialconditions']['gdd_1_0'] = 0
            nml['initialconditions']['gdd_2_0'] = -450
            nml['initialconditions']['laiinitialevetr'] = 4
            nml['initialconditions']['laiinitialdectr'] = 1
            nml['initialconditions']['laiinitialgrass'] = 1.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.3
            nml['initialconditions']['porosity0'] = 0.2
        elif LeafCycle == 2:
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.3
        elif LeafCycle == 3:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.6
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 4:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4.5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 5:  # Summer
            nml['initialconditions']['gdd_1_0'] = 300
            nml['initialconditions']['gdd_2_0'] = 0
            nml['initialconditions']['laiinitialevetr'] = 5.1
            nml['initialconditions']['laiinitialdectr'] = 5.5
            nml['initialconditions']['laiinitialgrass'] = 5.9
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 6:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4, 5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 7:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.5
            nml['initialconditions']['porosity0'] = 0.4
        elif LeafCycle == 8:  # Late Autumn
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.2

        nml['initialconditions']['snowinitially'] = snowinitially

        nml.write(initfileout, force=True)

    # def startWorker(self, vlayer, nbr_header, poly_field, Metfile_path, start_DLS, end_DLS, LCF_from_file, LCFfile_path, LCF_Paved,
    #              LCF_buildings, LCF_evergreen, LCF_decidious, LCF_grass, LCF_baresoil, LCF_water, IMP_from_file, IMPfile_path,
    #              IMP_heights_mean, IMP_z0, IMP_zd, IMP_fai, IMPveg_from_file, IMPvegfile_path, IMPveg_heights_mean_eve,
    #              IMPveg_heights_mean_dec, IMPveg_fai_eve, IMPveg_fai_dec, pop_density, widget_list,
    #              land_use_from_file, land_use_file_path, lines_to_write, plugin_dir, output_file_list, map_units, header_sheet, output_dir,
    #              day_since_rain, leaf_cycle, soil_moisture, file_code, utc, checkBox_twovegfiles, IMPvegfile_path_dec, IMPvegfile_path_eve, pop_density_day, daypop):

    #     worker = Worker(vlayer, nbr_header, poly_field, Metfile_path, start_DLS, end_DLS, LCF_from_file, LCFfile_path, LCF_Paved,
    #              LCF_buildings, LCF_evergreen, LCF_decidious, LCF_grass, LCF_baresoil, LCF_water, IMP_from_file, IMPfile_path,
    #              IMP_heights_mean, IMP_z0, IMP_zd, IMP_fai, IMPveg_from_file, IMPvegfile_path, IMPveg_heights_mean_eve,
    #              IMPveg_heights_mean_dec, IMPveg_fai_eve, IMPveg_fai_dec, pop_density, widget_list,
    #              land_use_from_file, land_use_file_path, lines_to_write, plugin_dir, output_file_list, map_units, header_sheet, output_dir,
    #              day_since_rain, leaf_cycle, soil_moisture, file_code, utc, checkBox_twovegfiles, IMPvegfile_path_dec, IMPvegfile_path_eve, pop_density_day, daypop)

    #     self.dlg.runButton.setText('Cancel')
    #     self.dlg.runButton.clicked.disconnect()
    #     self.dlg.runButton.clicked.connect(worker.kill)
    #     self.dlg.closeButton.setEnabled(False)

    #     thread = QThread(self.dlg)
    #     worker.moveToThread(thread)
    #     worker.finished.connect(self.workerFinished)
    #     worker.error.connect(self.workerError)
    #     worker.progress.connect(self.progress_update)
    #     thread.started.connect(worker.run)
    #     thread.start()
    #     self.thread = thread
    #     self.worker = worker

    # def workerFinished(self, ret):
    #     try:
    #         self.worker.deleteLater()
    #     except RuntimeError:
    #         pass
    #     self.thread.quit()
    #     self.thread.wait()
    #     self.thread.deleteLater()

    #     if ret == 1:
    #         self.dlg.runButton.setText('Generate')
    #         self.dlg.runButton.clicked.disconnect()
    #         self.dlg.runButton.clicked.connect(self.generate)
    #         self.dlg.closeButton.setEnabled(True)
    #         self.dlg.progressBar.setValue(0)
    #         self.iface.messageBar().pushMessage("SUEWS Prepare",
    #                                             "Process finished! Check General Messages (speech bubble, lower left) "
    #                                             "to obtain information of the process.", duration=5)
    #     else:
    #         self.dlg.runButton.setText('Generate')
    #         self.dlg.runButton.clicked.disconnect()
    #         self.dlg.runButton.clicked.connect(self.generate)
    #         self.dlg.closeButton.setEnabled(True)
    #         self.dlg.progressBar.setValue(0)
    #         QMessageBox.information(None, "SUEWS Prepare", "Operations cancelled, "
    #                                 "process unsuccessful! See the General tab in Log Meassages Panel "
    #                                 "(speech bubble, lower right) for more information.")

    # def workerError(self, errorstring):
    #     QgsMessageLog.logMessage(errorstring, level=Qgis.Critical)

    def progress_update(self):
        self.steps += 1
        self.dlg.progressBar.setValue(self.steps)
