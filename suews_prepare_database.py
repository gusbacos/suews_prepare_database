# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SUEWSPrepareDatabase
                                 A QGIS plugin
 Prepares inputdata for the SUEWS model using typology database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import  QAction, QMessageBox, QLabel, QLineEdit, QGridLayout, QVBoxLayout, QSpacerItem, QSizePolicy, QFileDialog, QComboBox
from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel, QgsVectorLayer, QgsMessageLog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .suews_prepare_database_dialog import SUEWSPrepareDatabaseDialog
import os.path
from .tabs.main_tab import MainTab
import webbrowser

#These are not needed here later
import numpy as np
import pandas as pd
import os
# import glob
from osgeo import gdal, osr
from .Utilities import f90nml
from .Utilities import RoughnessCalcFunction as rg
from .Utilities.misc import saveraster
from .Utilities.db_functions import *
from .Utilities.ssParms import *
# from .db import suews_db
from shutil import copyfile, rmtree
# import copy
# from .prepare_workertypo import Worker

os.environ['USE_PYGEOS'] = '0'
import geopandas as gpd
##############################################################

import processing

# importing native QGIS tools
# from qgis.analysis import QgsNativeAlgorithms
# QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())

################################################################


class SUEWSPrepareDatabase:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SUEWSPrepareDatabase_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&SUEWS Prepare (Database Typologies)')

        self.dlg = SUEWSPrepareDatabaseDialog()

        self.dlg.helpButton.clicked.connect(self.help)

        self.dlg.outputButton.clicked.connect(self.set_output_folder)
        self.dlg.runButton.clicked.connect(self.generate)

        self.outputDialog = QFileDialog()
        self.outputDialog.setFileMode(QFileDialog.Directory)
        self.outputDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.SSDialog = QFileDialog()
        self.SSDialog.setFileMode(QFileDialog.Directory)
        self.SSDialog.setOption(QFileDialog.ShowDirsOnly, True)

        self.fileDialog = QFileDialog()
        self.fileDialog.setFileMode(QFileDialog.ExistingFile)

        self.fileDialogISO = QFileDialog()
        self.fileDialogISO.setNameFilter("(*_isotropic.txt)")
        self.fileDialogISO.setFileMode(QFileDialog.ExistingFile)

        self.comboBoxCountry = None  
        self.comboBoxRegion = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None

        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        # self.wall_area = None
        self.daypop = 0
        self.typologies = 0
        self.start_DLS = 85
        self.end_DLS = 302
        self.day_since_rain = 0
        self.leaf_cycle = 0
        self.soil_moisture = 100
        self.utc = 0
        self.file_code = ''
        self.steps = 0
        # self.region = None

        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.Metfile_path = None
        # self.land_use_file_path = None
        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True

        self.vertheights ='10, 20'
        self.nlayers = 3
        self.skew = 2


    def tr(self, message):
        return QCoreApplication.translate('SUEWSPrepareDatabase', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/suews_prepare_database/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'SUEWS Prepare (Database Typologies)'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&SUEWS Prepare (Database Typologies)'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        self.output_dir = None
        self.LCFfile_path = None
        self.IMPfile_path = None
        self.IMPvegfile_path = None
        self.IMPvegfile_path_dec = None
        self.IMPvegfile_path_eve = None
        self.checkBox_twovegfiles = None
        self.checkBoxTypologies = None
        self.ss_dir = None
        # self.land_use_file_path = None
        self.dlg.textOutput.clear()
        self.setup_tabs()
        self.dlg.show()
        self.dlg.exec_()
        self.layerComboManagerPolygrid = None
        self.layerComboManagerPolyField = None
        self.fieldgen = None
        self.LCF_Paved = None
        self.LCF_Buildings = None
        self.LCF_Evergreen = None
        self.LCF_Decidious = None
        self.LCF_Grass = None
        self.LCF_Baresoil = None
        self.LCF_Water = None
        self.pop_density = None
        self.pop_density_day = None
        self.IMP_mean_height = None
        self.IMP_z0 = None
        self.IMP_zd = None
        self.IMP_fai = None
        self.IMPveg_mean_height_dec = None
        self.IMPveg_mean_height_eve = None
        self.IMPveg_fai_dec = None
        self.IMPveg_fai_eve = None
        self.wall_area = None
        self.layerComboManagerDEM = None
        self.layerComboManagerDSM = None
        self.layerComboManagerLC = None
        self.layerComboManagerPolygridTypo = None
        self.comboBoxRegion = None
        self.comboBoxCountry = None
        self.comboBoxPaved = None
        self.comboBoxBuilding = None
        self.comboBoxGrass = None
        self.comboBoxEvrTree = None
        self.comboBoxDecTree = None


    def help(self):
        url = "https://umep-docs.readthedocs.io/en/latest/pre-processor/Urban%20Energy%20Balance%20SUEWS%20Database%20Manager.html"
        webbrowser.open_new_tab(url)


    def set_output_folder(self):
        self.outputDialog.open()
        result = self.outputDialog.exec_()
        if result == 1:
            self.output_dir = self.outputDialog.selectedFiles()
            self.dlg.textOutput.setText(self.output_dir[0])
            self.dlg.runButton.setEnabled(1)


    def setup_tabs(self):
        self.dlg.tabWidget.clear()
        # self.widget_list = []

        main_tab = MainTab()
        self.setup_maintab(main_tab)

        self.dlg.tabWidget.addTab(main_tab, "Main settings")


    def setup_maintab(self, widget):

        self.LCF_from_file = True
        self.IMP_from_file = True
        self.IMPveg_from_file = True
        # widget.LCF_Frame.hide()
        # widget.IMP_Frame.hide()
        # widget.IMPveg_Frame.hide()

        self.comboBoxRegion = True
        self.comboBoxCountry = True
        self.comboBoxPaved = True
        self.comboBoxBuilding = True
        self.comboBoxGrass = True
        self.comboBoxEvrTree = True
        self.comboBoxDecTree = True
        
        #timezone = gpd.read_file(self.plugin_dir + '/Input/timezones/ne_10m_time_zones.shp')

        # Region
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        reg = pd.read_excel(db_path, sheet_name='Region', index_col= 'ID')
        country = pd.read_excel(db_path, sheet_name='Country', index_col= 'ID')
        veg = pd.read_excel(db_path, sheet_name='Veg', index_col= 'ID')
        nonveg = pd.read_excel(db_path, sheet_name='NonVeg', index_col= 'ID')
        
        nonveg['descOrigin'] = nonveg['Color']  + ' ' + nonveg['Description'] + ', ' + nonveg['Origin']
        veg['descOrigin'] = veg['Description'] + ', ' + veg['Origin']

        building_list = nonveg['descOrigin'].loc[nonveg['Surface'] == 'Buildings']
        paved_list = nonveg['descOrigin'].loc[nonveg['Surface'] == 'Paved']
        grass_list = veg['descOrigin'].loc[veg['Surface'] == 'Grass']
        dec_tree_list = veg['descOrigin'].loc[veg['Surface'] == 'Decidous Tree']
        evr_tree_list = veg['descOrigin'].loc[veg['Surface'] == 'Evergreen Tree']

        widget.comboBoxPaved.addItems(sorted(paved_list))
        widget.comboBoxBuilding.addItems(sorted(building_list))
        widget.comboBoxGrass.addItems(sorted(grass_list))
        widget.comboBoxEvrTree.addItems(sorted(evr_tree_list))
        widget.comboBoxDecTree.addItems(sorted(dec_tree_list))

        for cbox in [widget.comboBoxPaved, widget.comboBoxBuilding, widget.comboBoxEvrTree, widget.comboBoxDecTree, widget.comboBoxGrass]:
            cbox.setCurrentIndex(-1)

        reg_list = sorted(list(reg['Region'].unique()))
        widget.comboBoxRegion.addItems(reg_list)
        widget.comboBoxRegion.setCurrentIndex(-1)
        country['descOrigin'] = country['Country'] + ', ' + country['City']

        widget.comboBoxCountry.addItems(sorted(list(country['descOrigin'].unique())))
        widget.comboBoxCountry.setCurrentIndex(-1)

        #widget.LCF_checkBox.stateChanged.connect(lambda: self.hide_show_LCF(widget))
        #widget.IMP_checkBox.stateChanged.connect(lambda: self.hide_show_IMP(widget))
        # widget.IMPveg_checkBox.stateChanged.connect(lambda: self.hide_show_IMPveg(widget))
        widget.comboBoxRegion.currentIndexChanged.connect(lambda: self.region_changed(widget, country))
        widget.comboBoxCountry.currentIndexChanged.connect(lambda: self.country_changed(widget, country, veg, nonveg, reg))

        # widget.LUF_checkBox.stateChanged.connect(lambda: self.LUF_file(widget))
        # widget.WallArea_checkBox.stateChanged.connect(lambda: self.enable_wall_area(widget))
        widget.checkBoxTypology.stateChanged.connect(lambda: self.use_typologies(widget))
        widget.checkBox_day.stateChanged.connect(lambda: self.popdaystate(widget))

        self.layerComboManagerPolygrid = QgsMapLayerComboBox(widget.widgetPolygonLayer)
        self.layerComboManagerPolygrid.setCurrentIndex(-1)
        self.layerComboManagerPolygrid.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layerComboManagerPolygrid.setFixedWidth(175)
        self.layerComboManagerPolyField = QgsFieldComboBox(widget.widgetPolyField)
        self.layerComboManagerPolyField.setFilters(QgsFieldProxyModel.LongLong)
        self.layerComboManagerPolygrid.layerChanged.connect(self.layerComboManagerPolyField.setLayer)

        # New for Typology database
        self.layerComboManagerDSM = QgsMapLayerComboBox(widget.widgetDSM)
        self.layerComboManagerDSM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDSM.setFixedWidth(175)
        self.layerComboManagerDSM.setCurrentIndex(-1)
        self.layerComboManagerDEM = QgsMapLayerComboBox(widget.widgetDEM)
        self.layerComboManagerDEM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDEM.setFixedWidth(175)
        self.layerComboManagerDEM.setCurrentIndex(-1)
        self.layerComboManagerLC = QgsMapLayerComboBox(widget.widgetLC)
        self.layerComboManagerLC.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerLC.setFixedWidth(175)
        self.layerComboManagerLC.setCurrentIndex(-1)
        self.layerComboManagerPolygridTypo = QgsMapLayerComboBox(widget.widgetPolygonLayerTypo)
        self.layerComboManagerPolygridTypo.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layerComboManagerPolygridTypo.setFixedWidth(175)

        # self.reg_cbox = QComboBox(self.dlg.comboBoxRegion)
        # self.country_cbox = QComboBox(self.dlg.comboBoxCountry)
       
        self.pop_density = QgsFieldComboBox(widget.widgetPop)
        self.pop_density.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPolygrid.layerChanged.connect(self.pop_density.setLayer)

        self.pop_density_day = QgsFieldComboBox(widget.widgetPopDay)
        self.pop_density_day.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPolygrid.layerChanged.connect(self.pop_density_day.setLayer)
    
        widget.pushButtonImportLCF.clicked.connect(lambda: self.set_LCFfile_path(widget))
        widget.pushButtonImportIMPVeg.clicked.connect(lambda: self.set_IMPvegfile_path(widget))

        widget.pushButtonImportIMPVeg_eve.clicked.connect(lambda: self.set_IMPvegfile_path_eve(widget))
        widget.pushButtonImportIMPVeg_dec.clicked.connect(lambda: self.set_IMPvegfile_path_dec(widget))

        widget.pushButtonImportIMPBuild.clicked.connect(lambda: self.set_IMPfile_path(widget))
        widget.pushButtonImportMet.clicked.connect(lambda: self.set_metfile_path(widget))
        # widget.pushButtonImportLUF.clicked.connect(lambda: self.set_LUFfile_path(widget))

        widget.spinBoxStartDLS.valueChanged.connect(lambda: self.start_DLS_changed(widget.spinBoxStartDLS.value()))
        widget.spinBoxEndDLS.valueChanged.connect(lambda: self.end_DLS_changed(widget.spinBoxEndDLS.value()))

        widget.spinBoxSoilMoisture.valueChanged.connect(lambda: self.soil_moisture_changed(widget.spinBoxSoilMoisture.
                                                                                           value()))
        widget.comboBoxLeafCycle.currentIndexChanged.connect(lambda: self.leaf_cycle_changed(widget.comboBoxLeafCycle.
                                                                                             currentIndex()))
        widget.fileCodeLineEdit.textChanged.connect(lambda: self.file_code_changed(widget.fileCodeLineEdit.text()))
        widget.lineEditUTC.textChanged.connect(lambda: self.utc_changed(widget.lineEditUTC.text()))
        # self.layerComboManagerPolygrid.layerChanged.connect(lambda: self.grid_layer_changed(widget, timezone))

        #SS related GUI things
        widget.pushButtonImportSS.clicked.connect(lambda: self.set_SSfolder_path(widget))
        widget.SS_comboBox.currentIndexChanged.connect(lambda: self.height_option_SS(widget.SS_comboBox.currentIndex()))
        widget.SS_LineEdit_constant.textChanged.connect(lambda: self.vertHeights_changed(widget.SS_LineEdit_constant.text()))
        widget.spinBoxLayers.valueChanged.connect(lambda: self.layersSS_changed(widget.spinBoxLayers.value()))
        widget.SS_checkBox_skew.stateChanged.connect(lambda: self.SS_skew(widget))


    def set_SSfolder_path(self, widget):
        self.SSDialog.open()
        result = self.SSDialog.exec_()
        if result == 1:
            self.ss_dir = self.SSDialog.selectedFiles()
            widget.textInputIMPDataSS.setText(self.ss_dir[0])


    def height_option_SS(self, value):
        self.heightMethod = value


    def layersSS_changed(self, value):
        self.nlayers = value


    def vertHeights_changed(self, heights):      
        self.vertheights = heights


    def SS_skew(self, widget):
        if widget.SS_checkBox_skew.isChecked():
            self.skew = 2
        else:
            self.skew = 1

    # def useconstanheight_option_SS(self, widget):
    #     if widget.SS_checkBox_constant.isChecked():
    #         self.heightMethod = 1

    def soil_moisture_changed(self, value):
        self.soil_moisture = value


    def utc_changed(self, index):
        self.utc = index


    def leaf_cycle_changed(self, index):
        self.leaf_cycle = index


    def file_code_changed(self, code):
        self.file_code = code


    def region_changed(self, widget, country):
        region_sel = widget.comboBoxRegion.currentText()
        country['descOrigin'] = country['Country'] + ', ' + country['City']

        country_list = list(country['descOrigin'].loc[country['Region'] == region_sel])
        widget.comboBoxCountry.clear()
        widget.comboBoxCountry.addItems(country_list)


    def print_reg(self, widget):
        region_sel = widget.comboBoxRegion.currentText()
        return region_sel
    
   
    def print_country(self, widget):
        country_sel = widget.comboBoxCountry.currentText()
        return country_sel
    

    def country_changed(self, widget, country, veg, nonveg, reg):

        country_sel = widget.comboBoxCountry.currentText()
        reg_sel = widget.comboBoxRegion.currentText()

        self.country_str = country_sel
        self.region_str = reg_sel

        country['descOrigin'] = country['Country'] + ', ' + country['City']
        
        # Uodate region according to country if country is chosen before region
        try:
            if  country.loc[country['descOrigin'] == country_sel]['Region'].item() == reg_sel:
                pass
            else:
                reg_list = [widget.comboBoxRegion.itemText(i) for i in range(widget.comboBoxRegion.count())]
                indexer = reg_list.index(country['Region'].loc[country['descOrigin'] == country_sel].item())
                widget.comboBoxRegion.setCurrentIndex(indexer)
        except:
            pass
      
        try:
            id = country.loc[country['descOrigin'] == country_sel ].index.item()
        except:
            id = country.index[0]

        df_country = country.loc[id]

        def decide_country_region(sel_table, col, comboBox):
            if str(df_country[col]) == 'nan':
                    try:
                        var = reg.loc[reg['Region'] == df_country['Region'], col].item()
                        var_text = sel_table.loc[var, 'descOrigin']
                        cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                        indexer = cbox_list.index(var_text)
                    except:
                        indexer = 0
            else:
                var = df_country[col]
                var_text = sel_table.loc[var, 'descOrigin']
                cbox_list = [comboBox.itemText(i) for i in range(comboBox.count())]
                indexer = cbox_list.index(var_text)
    
            comboBox.setCurrentIndex(indexer)
    
        decide_country_region(nonveg, 'Paved', widget.comboBoxPaved)
        decide_country_region(nonveg, 'Buildings', widget.comboBoxBuilding)
        decide_country_region(veg, 'Evergreen Tree', widget.comboBoxEvrTree)
        decide_country_region(veg, 'Decidous Tree', widget.comboBoxDecTree)
        decide_country_region(veg, 'Grass', widget.comboBoxGrass)


    def use_typologies(self, widget):
        if widget.checkBoxTypology.isChecked():
            self.typologies = 1
        else:
            self.typologies = 0


    def popdaystate(self, widget):
        if widget.checkBox_day.isChecked():
            self.daypop = 1
        else:
            self.daypop = 0


    def set_LCFfile_path(self, widget):
        self.fileDialogISO.open()
        result = self.fileDialogISO.exec_()
        if result == 1:
            self.LCFfile_path = self.fileDialogISO.selectedFiles()
            widget.textInputLCFData.setText(self.LCFfile_path[0])
        else:
            self.LCFfile_path = None
            widget.textInputLCFData.setText('')


    def set_IMPfile_path(self, widget): #TODO Change the same as function above
        self.IMPfile_path = self.fileDialogISO.getOpenFileName()
        widget.textInputIMPData.setText(self.IMPfile_path[0])


    def set_IMPvegfile_path(self, widget):
        self.IMPvegfile_path = self.fileDialogISO.getOpenFileName()
        widget.textInputIMPVegData.setText(self.IMPvegfile_path[0])


    def set_IMPvegfile_path_dec(self, widget):
        self.IMPvegfile_path_dec = self.fileDialogISO.getOpenFileName()
        widget.textInputIMPDecData.setText(self.IMPvegfile_path_dec)


    def set_IMPvegfile_path_eve(self, widget):
        self.IMPvegfile_path_dec = self.fileDialogISO.getOpenFileName()
        widget.textInputIMPEveData.setText(self.IMPvegfile_path_eve[0])


    def set_metfile_path(self, widget):
        self.Metfile_path = self.fileDialog.getOpenFileName()
        widget.textInputMetData.setText(self.Metfile_path[0])


    def start_DLS_changed(self, value):
        self.start_DLS = value


    def end_DLS_changed(self, value):
        self.end_DLS = value


    def unload_widget(self):
        self.dlg.tabWidget.clear()


    def generate(self, widget):
        # First check that all part of the interface have been filled in correclty
        # output dir
        if self.output_dir is None:
            QMessageBox.critical(self.dlg, "Error", "No output directory selected")
            return  

        # metfile
        year = None
        year2 = None
        if self.Metfile_path is None:
            QMessageBox.critical(self.dlg, "Error", "Meteorological data file has not been provided,"
                                                " please check the main tab")
            return
        elif os.path.isfile(self.Metfile_path[0]):
            with open(self.Metfile_path[0]) as metfile:
                next(metfile)
                for line in metfile:
                    split = line.split()
                    if year == split[0]:
                        break
                    else:
                        if year2 == split[0]:
                            year = split[0]
                            break
                        elif year is None:
                            year = split[0]
                        else:
                            year2 = split[0]
        else:
            QMessageBox.critical(self.dlg, "Error", "Could not find the file containing meteorological data")
            return

        # # check polygon grid
        poly = self.layerComboManagerPolygrid.currentLayer()
        if poly is None:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        if not poly.geometryType() == 2:
            QMessageBox.critical(None, "Error", "No valid Polygon layer is selected")
            return
        
        poly_field = self.layerComboManagerPolyField.currentField()
        if poly_field == '':
            QMessageBox.critical(None, "Error", "An attribute field with unique fields must be selected")
            return

        vlayer = QgsVectorLayer(poly.source(), "polygon", "ogr")

        map_units = vlayer.crs().mapUnits()
        if not map_units == 0 or map_units == 1 or map_units == 2:
            QMessageBox.critical(self.dlg, "Error", "Could not identify the map units of the polygon layer coordinate "
                                 "reference system")
            return

        # population density  from polygon grid
        if self.pop_density.currentField() == '':
            QMessageBox.critical(None, "Error", "An attribute field including night-time population density (pp/ha) must be selected")
            return

        if self.daypop == 1:
            if self.pop_density_day.currentField() == '':
                QMessageBox.critical(None, "Error", "An attribute field including working population density (pp/ha) must be selected")
                return            

        # Leaf cycle
        if self.leaf_cycle == 0:
            QMessageBox.critical(self.dlg, "Error", "No leaf cycle period has been selected")
            return
        else:
            if not (self.leaf_cycle == 1 or self.leaf_cycle == 5):
                QMessageBox.critical(self.dlg,"Warning", "A transition period between Winter and Summer has been "
                                     "choosen. Preferably start the model run during Winter or Summer.")

        if self.LCF_from_file:
            if self.LCFfile_path is None:
                QMessageBox.critical(None, "Error", "Land cover fractions file has not been provided,"
                                                        " please check the main tab")
                return
            if not os.path.isfile(self.LCFfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing land cover fractions")
                return

        # Morphometric and land cover files
        if self.IMP_from_file:
            if self.IMPfile_path is None:
                QMessageBox.critical(None, "Error", "Building morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing building morphology")
                return

        if self.IMPveg_from_file:
            if self.IMPvegfile_path is None:
                QMessageBox.critical(None, "Error", "Vegetation morphology file has not been provided,"
                                                    " please check the main tab")
                return
            if not os.path.isfile(self.IMPvegfile_path[0]):
                QMessageBox.critical(None, "Error", "Could not find the file containing vegetation morphology")
                return

        if self.file_code == '':
            QMessageBox.critical(None, "Error", "Specify a file code prefix")
            return

        vlayer.source()

        # # DSM layer for aggegation
        dsmlayer = self.layerComboManagerDSM.currentLayer()
        if dsmlayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid ground and building DSM is selected")
            return

        demlayer = self.layerComboManagerDEM.currentLayer()
        if demlayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid DEM selected")
            return

        # # Land cover layer for aggegation
        lclayer = self.layerComboManagerLC.currentLayer()
        if lclayer is None:
            QMessageBox.critical(self.dlg, "Error", "No valid land cover grid is selected")
            return   

        polyTypolayer = self.layerComboManagerPolygridTypo.currentLayer()
        if polyTypolayer is None:
            QMessageBox.critical(None, "Error", "No valid Urban typology polygon layer is selected")
            return     

        #TODO add check for Region,
        #TODO add checker for CRS 
        #  

        # self.dlg.progressBar.setMaximum(vlayer.featureCount())     

        #Here worker loop starts. We make function. Then it is easier to put in worker latery

        # wait here. How shall we do????

        # QMessageBox.critical(None, "OK", "Frrk")
        # return  



        self.generateSiteSelect(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
                         self.IMP_from_file, self.IMPfile_path, self.IMP_z0, self.IMP_zd, self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, 
                         self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, self.plugin_dir, map_units, self.output_dir, self.file_code,
                         self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop,
                         polyTypolayer, dsmlayer, demlayer, lclayer, self.region_str, self.country_str, self.typologies,
                         self.heightMethod, self.vertheights, self.nlayers, self.skew, self.ss_dir)

        # self.startWorker(vlayer, poly_field, self.Metfile_path, self.start_DLS, self.end_DLS, self.LCF_from_file, self.LCFfile_path,
        #                  self.LCF_Paved, self.LCF_Buildings, self.LCF_Evergreen, self.LCF_Decidious, self.LCF_Grass, self.LCF_Baresoil,
        #                  self.LCF_Water, self.IMP_from_file, self.IMPfile_path, self.IMP_mean_height, self.IMP_z0, self.IMP_zd,
        #                  self.IMP_fai, self.IMPveg_from_file, self.IMPvegfile_path, self.IMPveg_mean_height_eve,
        #                  self.IMPveg_mean_height_dec, self.IMPveg_fai_eve, self.IMPveg_fai_dec, self.pop_density, 
        #                  self.plugin_dir, map_units,
        #                  self.output_dir, self.day_since_rain, self.leaf_cycle, self.soil_moisture, self.file_code,
        #                  self.utc, self.checkBox_twovegfiles, self.IMPvegfile_path_dec, self.IMPvegfile_path_eve, self.pop_density_day, self.daypop)

    #TODO: check so that utc is written correctly
    #TODO: 
    def generateSiteSelect(self, vlayer, poly_field, Metfile_path, start_DLS, end_DLS, LCF_from_file, LCFfile_path,
                         IMP_from_file, IMPfile_path, IMP_z0, IMP_zd, IMP_fai, IMPveg_from_file, IMPvegfile_path, 
                         IMPveg_fai_eve, IMPveg_fai_dec, pop_density, plugin_dir, map_units, output_dir, file_code,
                         utc, checkBox_twovegfiles, IMPvegfile_path_dec, IMPvegfile_path_eve, pop_density_day, daypop,
                         polyTypolayer, dsmlayer, demlayer, lclayer, region_str, country_str, checkBoxTypologies,
                         heightMethod, vertheights, nlayers, skew, ss_dir):

        save_txt_folder = output_dir[0]+ '/'
        temp_folder = plugin_dir + '/agg'
        build_raster_out = temp_folder + '/buildings.tif'

        ss_dict = {}
        veg_dict = {}
        nonVeg_dict = {}
        blend_dict= {}
        dict_out = {}

        surface_list = ['Paved', 'Buildings','Bare Soil']

        frac_to_surf_dict = {
            'hist_1' : 'Paved', 
            'hist_2' : 'Buildings', 
            'hist_3' : 'Grass', 
            'hist_4' : 'Evergreen Tree' ,
            'hist_5' : 'Decidous Tree' , 
            'hist_6' : 'Bare Soil',
            'hist_7' : 'Water',
            } 

        surf_to_code_dict = {
            'Paved' : 'Code_Paved',
            'Buildings' : 'Code_Bldgs',
            'Bare Soil': 'Code_Bsoil',
            'Grass' : 'Code_Grass',
            'Evergreen Tree' : 'Code_EveTr',
            'Decidous Tree' :  'Code_DecTr',
            'Water' : 'Code_Water' 
            } 

        # Read DB
        db_path = self.plugin_dir + '/Input/database.xlsx'  # TODO When in UMEP Toolbox, set this path to db in database manager
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por, reg, snow, AnEm, prof, ws, soil, ESTM, irr, country, type_id_dict,country_id_dict, reg_id_dict = read_DB(db_path)

        country_conv_dict = {} 
        reg_conv_dict = {}
        for index in list(country.index):
            country_conv_dict[index] = country.loc[index, 'Country'] + ', ' + country.loc[index, 'City']
        country_conv_dict_inv = {v: k for k, v in country_conv_dict.items()}
        for index in list(reg.index):
            reg_conv_dict[index] = reg.loc[index, 'Region']
        reg_conv_dict_inv = {v: k for k, v in reg_conv_dict.items()}
    
        # reg_sel = reg.loc[[reg_conv_dict_inv[region_str]]]
        country_sel = country.loc[[country_conv_dict_inv[country_str]]]

        column_list = country.drop(columns = ['Region','Country','City']).columns
        column_dict = {}
        for column in column_list:
            column_dict[column] = decide_country_or_region(column, country_sel, reg)

        # Fill Anthropogeinc Emissions
        AnEm_dict = fill_SUEWS_AnthropogenicEmission(column_dict['AnthropogenicCode'], column_dict, AnEm) # FIX!
        snow_dict = fill_SUEWS_Snow(column_dict['SnowCode'], snow, alb, em, ANOHM)
        water_dict = fill_SUEWS_Water(column_dict['Water'], water, alb, em, st, dr, ANOHM, ws, column_dict)
        cond_dict = sel_to_dict(cnd, 'Cnd', column_dict)
        # snow_dict = sel_to_dict(snow, 'Water_Code', column_dict)

        if LCF_from_file:
            LCF_dict = read_morph_txt(LCFfile_path[0])

        if IMP_from_file:
            IMP_dict = read_morph_txt(IMPfile_path[0])

        if IMPveg_from_file:
            IMPveg_dict = read_morph_txt(IMPvegfile_path[0])
        
        if checkBoxTypologies == 1:
        # DEM & DSM to array

            gdal.AllRegister()
            provider = demlayer.dataProvider()
            filePath_dem = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_dem)
            dem_arr = dataSet.ReadAsArray().astype(float)

            provider = dsmlayer.dataProvider()
            filePath_dsm = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_dsm)
            dsm_arr = dataSet.ReadAsArray().astype(float)
            
            provider = lclayer.dataProvider()
            filePath_lc = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_lc)
            # lc_arr = dataSet.ReadAsArray().astype(float)

            # # Clean temp folder
            try:
                rmtree(temp_folder)
            except OSError as e:
                print ("Error: %s - %s." % (e.filename, e.strerror))

            os.mkdir(temp_folder)

            output = {}

            # TODO Clip rastesr to speed up process
            # parin = {'INPUT': vlayer, 'OUTPUT':'TEMPORARY_OUTPUT'}
            # output['bbox'] = processing.run("native:boundingboxes",parin)
            # parin = {
            #     'INPUT':vlayer,
            #     'OVERLAY': output['bbox'],
            #     'OUTPUT':'TEMPORARY_OUTPUT'}
            # output['clip'] = processing.run("native:clip", parin)
            
            # Grid classified shp-file containing SUEWS typologies
            intersectPrefix = 'i'
            parin = { 'INPUT' : vlayer,
            'INPUT_FIELDS' : [], 
            'OUTPUT' : temp_folder + '/urbantypelayer.shp', # 'TEMPORARY_OUTPUT',#urbantypelayer,
            'OVERLAY' : polyTypolayer, 
            'OVERLAY_FIELDS' : [], 
            'OVERLAY_FIELDS_PREFIX' : intersectPrefix }
            output['gridded_shp'] = processing.run('native:intersection', parin)

            # isolate buildings in dsm to be able to calculate mean height
            build_arr = dsm_arr-dem_arr
            build_arr[np.where(build_arr < 1.0)] = np.nan
            saveraster(gdal.Open(filePath_dsm), build_raster_out, build_arr)

            type_id = 'inewfield'
            height_prefix = '_bldheight'

            # Zonal statistics to calculate mean height within gridded polygon layer
            parin = {
                'INPUT':output['gridded_shp']['OUTPUT'],
                'INPUT_RASTER': build_raster_out,
                'RASTER_BAND':1,
                'COLUMN_PREFIX': height_prefix,
                'STATISTICS':[2], # [2] == mean
                'OUTPUT': temp_folder + '/zon_bldheight.shp' } # 'TEMPORARY_OUTPUT'}
            output['gridded_shp_bld'] = processing.run("native:zonalstatisticsfb", parin)

            # Zonal histogram to calculate fractions of lc in all gridded typologies
            prefix = 'hist_'
            parin =  {
                'INPUT_RASTER': filePath_lc,
                'RASTER_BAND': 1,
                'INPUT_VECTOR': output['gridded_shp']['OUTPUT'],
                'COLUMN_PREFIX': prefix,
                'OUTPUT': temp_folder + '/zon_hist.shp' } # 'TEMPORARY_OUTPUT'}
            output['gridded_shp_lc'] = processing.run("native:zonalhistogram",parin)

            # obtain pixelsize of raster in order to be able to calculate fractions later on
            lc_raster = gdal.Open(filePath_lc)
            lc_raster_gt = lc_raster.GetGeoTransform()
            pixelSizeX = lc_raster_gt[1]

            # vector layer gridded typologies
            vlayer_gt = output['gridded_shp']['OUTPUT'] #QgsVectorLayer(, "polygon", "ogr")

            field_list= []
            for fieldName in vlayer_gt.fields():
                field_list.append(fieldName.name())

            type_index = field_list.index(type_id)
            pai_dict = {}

            for feature in vlayer_gt.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                pai_dict[feat_id] = { i : 0 for i in list(vlayer_gt.uniqueValues(type_index))}

            for feature in vlayer_gt.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                typology = feature.attribute(type_id)
                area = feature.geometry().area()

                pai_dict[feat_id][typology] = area

            # vector layer with building heights
            vlayer_bh =output['gridded_shp_bld']['OUTPUT']

            field_list= []
            for fieldName in vlayer_bh.fields():
                field_list.append(fieldName.name())

            type_index = field_list.index(type_id)
            area_dict = {}

            for feature in vlayer_bh.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                area_dict[feat_id] = { i : 0 for i in list(vlayer_bh.uniqueValues(type_index))}
                pai_dict[feat_id] = { i : 0 for i in list(vlayer_bh.uniqueValues(type_index))}

            for feature in vlayer_bh.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                typology = feature.attribute(type_id)
                build_h = feature.attribute(height_prefix+'mean')
                area = feature.geometry().area()
                try:
                    volume = area * build_h
                except:
                    volume = area * 1
                
                area_dict[feat_id][typology] = area_dict[feat_id][typology] + volume
            
            frac_dict_bh = {} # create a new dictionary with fracions and remove typologies with fracion 0

            for i in area_dict:
                total_vol = sum(area_dict[i].values())
                frac_dict_bh[i] = {k:(v/total_vol) for k, v in area_dict[i].items() }
                frac_dict_bh[i] = {k:v for (k,v) in frac_dict_bh[i].items() if v > 0}

            # Calculate fractions of LC_classes hist_number indicate same as SUEWS surfaces, paved, building etc.
            vlayer_lc = output['gridded_shp_lc']['OUTPUT']

            field_list= ['hist_1', 'hist_2','hist_3','hist_4', 'hist_5','hist_6','hist_7'] # 'hist_1' : Paved, 'hist_2' : Buildings, 'hist_3' : 'Evergreen Trees', 'hist_4' : 'Evergreen Trees', 'hist_5': 'Grass' ,'hist_6': 'Bare Soil', 'hist_7' : 'Water'

            types_list= []
            for fieldName in vlayer_lc.fields():
                types_list.append(fieldName.name())

            type_index = types_list.index(type_id)

            area_dict = {}

            for feature in vlayer_lc.getFeatures():
                feat_id = int(feature.attribute(poly_field))
                area_dict[feat_id] = { i : { i : 0 for i in field_list} for i in list(vlayer_lc.uniqueValues(type_index))}

            for feature in vlayer_lc.getFeatures():
                for gridtype in field_list:
                    feat_id = int(feature.attribute(poly_field))
                    typology = feature.attribute(type_id)
                    try:
                        area_dict[feat_id][typology][gridtype] = area_dict[feat_id][typology][gridtype] + feature.attribute(gridtype) #area_dict[feat_id][typology] + volume
                    except:
                        area_dict[feat_id][typology][gridtype] = 0 # 0 if no frac exist

            frac_dict_lc = {} # create a new dictionary with fracions  
            typology_list = list(area_dict[list(area_dict.keys())[0]].keys())

            for i in area_dict:
                frac_dict_lc[i] ={}
                for j in typology_list:
                    if sum(area_dict[i][j].values()) > 0: # only select typologies active in the grid
                        frac_dict_lc[i][j] = {k:(v/pixelSizeX) for k, v in area_dict[i][j].items()}
                        frac_dict_lc[i][j] = {k:v for (k,v) in area_dict[i][j].items() if v > 0} # remove typologies with fracion 0

            frac_dict_surf = {}
            for id in frac_dict_lc:
                frac_dict_surf[id] = {}
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        frac_dict_surf[id][surf] = 0
                        
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        try:
                            frac_dict_surf[id][surf] = frac_dict_surf[id][surf] + frac_dict_lc[id][typology][surf]
                        except:
                            pass 

            for id in frac_dict_lc:              
                for typology in frac_dict_lc[id].keys():
                    for surf in field_list:
                        try:
                            frac_dict_lc[id][typology][surf] = frac_dict_lc[id][typology][surf] / frac_dict_surf[id][surf]
                        except:
                            pass
        
            for id in frac_dict_bh: # CHange to ID for GRID!

                type_list = list(frac_dict_bh[id].keys())
                type_list_int = []

                for element in type_list:
                    type_list_int.append(type_id_dict[element])

                ss_dict[id] = {}
                dict_out[id] = {}
        
                # SUEWS_NonVeg
                nonVeg_dict[id] = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = type_list_int)
        
                blend_dict[id] = {}
                
                for surface in surface_list:
                    blend_dict[id][surface] = {}
                    dict_out[id][surface] = {}

                    params = list(nonVeg_dict[id][surface_list[0]][type_list_int[0]].keys())

                    for param in params:
                        blend_dict[id][surface][param] = {}

                        for typology in type_list_int:
                            blend_dict[id][surface][param][typology] = nonVeg_dict[id][surface][typology][param]

                    # Check if the codes needs to be averaged or not
                    unique_values = list(set(list(blend_dict[id][surface]['Code'].values())))        

                    if len(unique_values) == 1:
                        ss_dict[id][surf_to_code_dict[surface]] = str(unique_values[0]) # if they all same, just set same code
                        dict_out[id][surface] = nonVeg_dict[id][surface][typology]
                    else:
                        tab, OHM, ESTM = blend_nonveg(blend_dict, surface, frac_dict_bh, frac_dict_lc, id, ESTM, OHM,type_id_dict, frac_to_surf_dict, column_dict)
                        ss_dict[id][surf_to_code_dict[surface]] = tab[surface]['Code']
                        dict_out[id][surface] = tab[surface]
                        
            dict_out[9999] = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = False)

            save_NonVeg_types(dict_out, save_txt_folder)
        
            nonVeg_dict = dict_out.copy()
        else:
            nonVeg_dict = fill_SUEWS_NonVeg(Type, nonveg, alb, em, st, dr, ANOHM, ws, column_dict, urbType = False)
            save_SUEWS_txt(pd.DataFrame.from_dict(nonVeg_dict, orient='index').set_index('Code'), 'SUEWS_NonVeg.txt', save_txt_folder)      

        veg_dict = fill_SUEWS_Veg(Type, veg, alb, em, LAI, st, LGP, dr, VG, ANOHM,  MVCND, por, ws, urbType = False, column_dict = column_dict)
        save_SUEWS_txt(pd.DataFrame.from_dict(veg_dict, orient='index').set_index('Code'), 'SUEWS_Veg.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(AnEm_dict, orient = 'index').T.set_index('Code'), 'SUEWS_AnthropogenicEmission.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(water_dict, orient = 'index').set_index('Code'), 'SUEWS_Water.txt', save_txt_folder)
        save_SUEWS_txt(pd.DataFrame.from_dict(cond_dict, orient = 'index').T.set_index('Code'), 'SUEWS_Conductance.txt', save_txt_folder)

        save_snow(snow_dict, save_txt_folder)

        # Save Profiles
        profiles = ['TrafficRate_WD','TrafficRate_WE', 'EnergyUseProfWD','EnergyUseProfWE','ActivityProfWD','ActivityProfWE','PopProfWD','PopProfWE', 'SnowClearingProfWD', 'SnowClearingProfWE','WaterUseProfManuWD','WaterUseProfManuWE','WaterUseProfAutoWD','WaterUseProfAutoWE']        
        profiles_list = []
        for i in profiles:
            profiles_list.append(column_dict[i])
            profiles_list = list(set(profiles_list))

        fill_SUEWS_profiles(profiles_list, save_txt_folder, prof) # TODO IMORGON!
        # presave leads to save_SUEWS_txt
        # presave(prof, 'Profiles', profiles_list, save_txt_folder)
        presave(irr, 'Irrigation', [column_dict['IrrigationCode']], save_txt_folder)
        presave(soil, 'Soil', [column_dict['SoilTypeCode']], save_txt_folder)

        # Spartacus
        # ? 

        ########################### CALC ################################
        
        ESTM_list = []
        OHM_list = []
        BIOCO2_list = []

        for dict_sel in [nonVeg_dict, veg_dict, snow_dict, water_dict ]:
        
            try:
                for i in dict_sel.keys():
                    try:
                        ESTM_list.append(dict_sel[i]['ESTMCode'])
                    except:
                        pass
                    try:
                        OHM_list.append(dict_sel[i]['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel[i]['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel[i]['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel[i]['OHMCode_WinterDry'])
                    except:
                        OHM_list.append(dict_sel['OHMCode_SummerWet'])
                        OHM_list.append(dict_sel['OHMCode_SummerDry'])
                        OHM_list.append(dict_sel['OHMCode_WinterWet'])
                        OHM_list.append(dict_sel['OHMCode_WinterDry'])

                    try:
                        BIOCO2_list.append(dict_sel[i]['BiogenCO2Code'])
                    except:
                        pass
            except:
                for feat_id in list(dict_sel.keys()):
                    for surf in surface_list:
                            ESTM_list.append(dict_sel[feat_id][surf]['ESTMCode'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerWet'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_SummerDry'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])
                            OHM_list.append(dict_sel[feat_id][surf]['OHMCode_WinterWet'])

        ESTM_list = list(set(ESTM_list))
        OHM_list = list(set(OHM_list))
        BIOCO2_list = list(set(BIOCO2_list))

        presave(ESTM, 'ESTMCoefficients', ESTM_list, save_txt_folder)
        presave(OHM, 'OHMCoefficients', OHM_list, save_txt_folder)
        presave(BIOCO2, 'BiogenCO2', BIOCO2_list, save_txt_folder)

        # ################################################################################################################################
        
        # ################################################################################################################################

        ind = 1
        # Loop Start for each Grid
        for feature in vlayer.getFeatures():

            # if self.killed is True:
            #     break
            # new_line = [None] * (len(self.nbr_header) - 3)
            # print_line = True
            # feat_id = int(feature.attribute(self.poly_field))
            # code = "Grid"
            # index = self.find_index(code)
            # new_line[index] = str(feat_id)
            # print('Processing ID: ' + str(feat_id))
            # # if killed is True:
            # #     break
            # # new_line = [None] * (len(nbr_header) - 3)
            # print_line = True
            feat_id = int(feature.attribute(poly_field))
    
            print('Processing ID: ' + str(feat_id))
            year = None
            year2 = None
            ss_dict[feat_id] = {}

            # Write GridLayoutXXX.nml
            print(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt')
            ssVect = np.loadtxt(ss_dir[0] + '/' + file_code + '_IMPGrid_SS_' + str(feat_id) + '.txt', skiprows = 1) #vertical info from IMP calc
            writeGridLayout(ssVect, heightMethod, vertheights, nlayers, skew, file_code, str(feat_id), save_txt_folder)
            
            try:
                ss_dict[feat_id]['Code_Paved'] = nonVeg_dict[feat_id]['Paved']['Code']
                ss_dict[feat_id]['Code_Bldgs'] = nonVeg_dict[feat_id]['Buildings']['Code']
                ss_dict[feat_id]['Code_Bsoil'] = nonVeg_dict[feat_id]['Bare Soil']['Code']
            
                # if grid doesnt contain any typology, set to standard for region/country
                # nonVeg_dict will not have information for grids without typloogy and raise error
            except:
                ss_dict[feat_id]['Code_Paved'] = column_dict['Paved']
                ss_dict[feat_id]['Code_Bldgs'] = column_dict['Buildings']
                ss_dict[feat_id]['Code_Bsoil'] = column_dict['Bare Soil']

            ss_dict[feat_id]['Code_EveTr'] = veg_dict['Evergreen Tree']['Code']
            ss_dict[feat_id]['Code_DecTr'] = veg_dict['Decidous Tree']['Code']
            ss_dict[feat_id]['Code_Grass'] = veg_dict['Grass']['Code']
            ss_dict[feat_id]['Code_Water'] = water_dict['Water']['Code']

            if Metfile_path is None:
                QMessageBox.critical(None, "Error", "Meteorological data file has not been provided,"
                                                    " please check the main tab")
                return
            elif os.path.isfile(Metfile_path[0]):
                with open(Metfile_path[0]) as file:
                    next(file)
                    for line in file:
                        split = line.split()
                        if year == split[0]:
                            break
                        else:
                            if year2 == split[0]:
                                year = split[0]
                                break
                            elif year is None:
                                year = split[0]
                            else:
                                year2 = split[0]

                # figure out the time res of input file
                if ind == 1:
                    met_old = np.genfromtxt(Metfile_path[0], skip_header=1, skip_footer=2)
                    id = met_old[:, 1]
                    it = met_old[:, 2]
                    imin = met_old[:, 3]
                    dectime0 = id[0] + it[0] / 24 + imin[0] / (60 * 24)
                    dectime1 = id[1] + it[1] / 24 + imin[1] / (60 * 24)
                    res = int(np.round((dectime1 - dectime0) * (60 * 24)))
                    ind = 999

            else:
                QMessageBox.critical(None, "Error",
                                        "Could not find the file containing meteorological data")
                return

            old_cs = osr.SpatialReference()
            vlayer_ref = vlayer.crs().toWkt()
            old_cs.ImportFromWkt(vlayer_ref)

            wgs84_wkt = """
            GEOGCS["WGS 84",
                DATUM["WGS_1984",
                    SPHEROID["WGS 84",6378137,298.257223563,
                        AUTHORITY["EPSG","7030"]],
                    AUTHORITY["EPSG","6326"]],
                PRIMEM["Greenwich",0,
                    AUTHORITY["EPSG","8901"]],
                UNIT["degree",0.01745329251994328,
                    AUTHORITY["EPSG","9122"]],
                AUTHORITY["EPSG","4326"]]"""

            new_cs = osr.SpatialReference()
            new_cs.ImportFromWkt(wgs84_wkt)

            transform = osr.CoordinateTransformation(old_cs, new_cs)

            centroid = feature.geometry().centroid().asPoint()
            area = feature.geometry().area()

            if map_units == 0:
                hectare = area * 0.0001 # meter

            elif map_units == 1:
                hectare = area / 107640. # square foot

            else:
                hectare = area
            gdalver = float(gdal.__version__[0])
            lonlat = transform.TransformPoint(centroid.x(), centroid.y())
            code = "lat"

            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3

            code = "lng"
            if gdalver == 3.:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[1] #changed to gdal 3
            else:
                ss_dict[feat_id][code] =  '%.6f' % lonlat[0] #changed to gdal 3

            altitude = 0
            day = 1
            hour = 0
            minute = 0

            if LCF_from_file:
                LCF_paved     = LCF_dict[feat_id]['Paved']
                LCF_buildings = LCF_dict[feat_id]['Buildings']
                LCF_evergreen = LCF_dict[feat_id]['EvergreenTrees']
                LCF_decidious = LCF_dict[feat_id]['DecidiousTrees']
                LCF_grass     = LCF_dict[feat_id]['Grass']
                LCF_baresoil  = LCF_dict[feat_id]['Baresoil']
                LCF_water     = LCF_dict[feat_id]['Water']
            # else:
            #     LCF_paved = feature.attribute(LCF_paved.getFieldName())
            #     LCF_buildings = feature.attribute(LCF_buildings.getFieldName())
            #     LCF_evergreen = feature.attribute(LCF_evergreen.getFieldName())
            #     LCF_decidious = feature.attribute(LCF_decidious.getFieldName())
            #     LCF_grass = feature.attribute(LCF_grass.getFieldName())
            #     LCF_baresoil = feature.attribute(LCF_baresoil.getFieldName())
            #     LCF_water = feature.attribute(LCF_water.getFieldName())

            irrFr_EveTr = 0
            irrFr_DecTr = 0
            irrFr_Grass = 0
            IrrFr_Bldgs = 0
            IrrFr_Paved = 0
            IrrFr_Water = 0
            IrrFr_BSoil = 0

            TrafficRate_WD = 0.01 ## Already in dict
            TrafficRate_WE = 0.01 ## Already in dict

            QF0_BEU_WD = 0.88 ## Already in dict
            QF0_BEU_WE = 0.88 ## Already in dict
           
            if IMP_from_file:
                IMP_heights_mean = IMP_dict[feat_id]['zH']
                IMP_z0 = IMP_dict[feat_id]['z0']
                IMP_zd = IMP_dict[feat_id]['zd']
                IMP_fai = IMP_dict[feat_id]['fai']
                IMP_max = IMP_dict[feat_id]['zHmax']
                IMP_sd = IMP_dict[feat_id]['zHstd']
                IMP_wai = IMP_dict[feat_id]['wai']
            # else:
            #     IMP_heights_mean = feature.attribute(IMP_mean_height.getFieldName())
            #     IMP_z0 = feature.attribute(IMP_z0.getFieldName())
            #     IMP_zd = feature.attribute(IMP_zd.getFieldName())
            #     IMP_fai = feature.attribute(IMP_fai.getFieldName())
            #     IMP_wai = feature.attribute(IMP_wai.getFieldName())

            if IMPveg_from_file:
                IMPveg_heights_mean_eve = IMPveg_dict[feat_id]['zH']
                IMPveg_heights_mean_dec = IMPveg_dict[feat_id]['zH']
                IMPveg_fai_eve = IMPveg_dict[feat_id]['fai']
                IMPveg_fai_dec = IMPveg_dict[feat_id]['fai']
                IMPveg_max_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_sd_eve = IMPveg_dict[feat_id]['zHmax']  #TODO not used yet
                IMPveg_max_dec = IMPveg_dict[feat_id]['zHstd']
                IMPveg_sd_dec = IMPveg_dict[feat_id]['zHstd']
            # else:
            #     IMPveg_heights_mean_eve = feature.attribute(IMPveg_mean_height_eve.getFieldName())
            #     IMPveg_heights_mean_dec = feature.attribute(IMPveg_mean_height_dec.getFieldName())
            #     IMPveg_fai_eve = feature.attribute(IMPveg_fai_eve.getFieldName())
            #     IMPveg_fai_dec = feature.attribute(IMPveg_fai_dec.getFieldName())

            # New calcualtion of rouhgness params v2017 (Kent et al. 2017b)
            # Evergreen not yet included in the calculations
            LCF_de = float(LCF_decidious)
            LCF_ev = float(LCF_evergreen)
            LCF_bu = float(LCF_buildings)
            LCF_tr = LCF_de + LCF_ev # temporary fix while ev and de is not separated, issue 155
            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                zH = 0
                zMAx = 0
            else:
                zH = (float(IMP_heights_mean) * LCF_bu + float(IMPveg_heights_mean_eve) * LCF_ev + float(IMPveg_heights_mean_dec) * LCF_de) / (LCF_bu + LCF_ev + LCF_de)                    
                zMax = max(float(IMPveg_max_dec),float(IMP_max))

            if (LCF_de  == 0 and LCF_ev == 0 and LCF_bu == 0):
                sdComb = 0
                IMP_z0 = 0
                IMP_zd = 0
                # sdTree = np.sqrt((IMPveg_sd_eve ^ 2 / LCF_evergreen * area) + (IMPveg_sd_dec ^ 2 / LCF_decidious * area))  # not used yet
            elif (LCF_tr == 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMP_sd) ** 2. / (LCF_bu * float(area)))  # Fix (fLCF_bu) issue #162
            elif (LCF_tr != 0 and LCF_bu == 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)))
            elif (LCF_tr != 0 and LCF_bu != 0):
                sdComb = np.sqrt(float(IMPveg_sd_dec) ** 2. / (LCF_tr * float(area)) + float(IMP_sd) ** 2. / (LCF_bu * float(area)))

            pai = LCF_bu + LCF_ev + LCF_de
            
            # paiall = (planareaB + planareaV) / AT
            porosity = 0.2  # This should change with season. Net, set for Summer
            Pv = ((-1.251 * porosity ** 2) / 1.2) + ((0.489 * porosity) / 1.2) + (0.803 / 1.2)  # factor accounting for porosity to correct total fai in roughness calc Kent et al. 2017b
            # faiall_rgh = (frontalareaB + (Pv * frontalareaV)) / (AT / (1 / scale))  # frontal area used in roughness calculation Kent et al. 2017b
            fai = Pv * (float(IMPveg_fai_eve) + float(IMPveg_fai_dec)) + float(IMP_fai)
            if (fai == 0. and pai == 1.):
                IMP_z0 = 0.
                IMP_zd = zH
            elif (fai == 0. and pai < 1.):
                IMP_z0 = 0.
                IMP_zd = 0.
            else:
                IMP_zd, IMP_z0 = rg.RoughnessCalc("Kan", zH, fai, pai, zMax, sdComb)

            # clean up and give open country values if non-existant
            if np.isnan(IMP_z0) or IMP_z0 < 0.03:
                IMP_z0 = 0.03
            if np.isnan(IMP_zd) or IMP_zd < 0.2:
                IMP_zd = 0.2

            # # new for z (2017)
            try:
                z = ((float(IMP_heights_mean) * float(LCF_buildings) + float(IMPveg_heights_mean_eve) * float(LCF_evergreen) +
                    float(IMPveg_heights_mean_dec) * float(LCF_decidious)) / (float(LCF_buildings) + float(LCF_evergreen) + float(LCF_decidious))) * 3
            except:
                z = 10.
            if z < 10.:
                z = 10.

            if pop_density is not None:
                pop_density_night = feature.attribute(pop_density.currentField())
            else:
                pop_density_night = -999

            if daypop == 1:
                pop_density_day = feature.attribute(pop_density_day.currentField())
            else:
                pop_density_day = pop_density_night

            LUMPS_drate = 0.25
            LUMPS_Cover = 1
            LUMPS_MaxRes = 10
            NARP_Trans = 1

            flow_change = 0
            RunoffToWater = 0.1
            PipeCap = 100
            GridConn1of8 = 0
            Fraction1of8 = 0
            GridConn2of8 = 0
            Fraction2of8 = 0
            GridConn3of8 = 0
            Fraction3of8 = 0
            GridConn4of8 = 0
            Fraction4of8 = 0
            GridConn5of8 = 0
            Fraction5of8 = 0
            GridConn6of8 = 0
            Fraction6of8 = 0
            GridConn7of8 = 0
            Fraction7of8 = 0
            GridConn8of8 = 0
            Fraction8of8 = 0
    
            WhitinGridPav = 661
            WhitinGridBldg = 662
            WhitinGridEve = 663
            WhitinGridDec = 664
            WhitinGridGrass = 665
            WhitinGridUnmanBsoil = 666
            WhitinGridWaterCode = 667

            Fr_ESTMClass_Paved1 = 0.  ## Already in dict
            Fr_ESTMClass_Paved2 = 1.  ## Already in dict
            Fr_ESTMClass_Paved3 = 0.  ## Already in dict
            Code_ESTMClass_Paved1 = 99999  ## Already in dict
            Code_ESTMClass_Paved2 = 807  ## Already in dict
            Code_ESTMClass_Paved3 = 99999  ## Already in dict
            Fr_ESTMClass_Bldgs1 = 1.0  ## Already in dict
            Fr_ESTMClass_Bldgs2 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs3 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs4 = 0.  ## Already in dict
            Fr_ESTMClass_Bldgs5 = 0.  ## Already in dict
            Code_ESTMClass_Bldgs1 = 801  ## Already in dict
            Code_ESTMClass_Bldgs2 = 99999  ## Already in dict
            Code_ESTMClass_Bldgs3 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs4 = 99999 ## Already in dict
            Code_ESTMClass_Bldgs5 = 99999 ## Already in dict

            SUEWS_param_dict ={
                # 
                "Year" : year,
                "StartDLS": start_DLS,
                "EndDLS" : end_DLS,
                # 'lat' : "set in code"
                # 'lon' : set in code
                "Timezone" : utc,
                "SurfaceArea" : hectare,
                'Alt' :  altitude,
                'id' : day,
                'ih': hour,
                "imin" : minute,
                # Fractions
                "Fr_Paved" : LCF_paved,
                "Fr_Bldgs" : LCF_buildings,
                "Fr_EveTr" : LCF_evergreen,
                "Fr_DecTr" : LCF_decidious,
                "Fr_Grass" : LCF_grass,
                "Fr_Bsoil" : LCF_baresoil,
                "Fr_Water" : LCF_water,
                # Irrigation Fraction
                "IrrFr_Paved" : IrrFr_Paved,
                "IrrFr_Bldgs" : IrrFr_Bldgs,
                "IrrFr_EveTr" : irrFr_EveTr,
                "IrrFr_DecTr" : irrFr_DecTr,
                "IrrFr_Grass" : irrFr_Grass,
                "IrrFr_BSoil" : IrrFr_BSoil,
                "IrrFr_Water" : IrrFr_Water,
                # Anthropoghenic Emis
                "QF0_BEU_WD" : QF0_BEU_WD,
                "QF0_BEU_WE" : QF0_BEU_WE,
                # Morphological params
                "H_Bldgs" : IMP_heights_mean,
                "H_EveTr" : IMPveg_heights_mean_eve,
                "H_DecTr" : IMPveg_heights_mean_dec,
                "z0" : '%.3f' % IMP_z0,
                "zd" : '%.3f' % IMP_zd,
                "z"  : '%.3f' % z,
                "FAI_Bldgs" : IMP_fai,
                "FAI_EveTr" : IMPveg_fai_eve,
                "FAI_DecTr" : IMPveg_fai_dec,
                "AreaWall" : (float(IMP_wai) * hectare * 10000.),
                "CondCode" : column_dict['Cnd'],
                "SnowCode" : snow_dict['Code'],
                'TrafficRate_WD' : column_dict['TrafficRate_WD'],
                'TrafficRate_WE' : column_dict['TrafficRate_WE'], 
                'SnowClearingProfWD' : column_dict['SnowClearingProfWD'], 
                'SnowClearingProfWE' : column_dict['SnowClearingProfWE'], 
                'AnthropogenicCode': column_dict['AnthropogenicCode'], 
                'IrrigationCode':  column_dict['IrrigationCode'], 
                'WaterUseProfManuWD': column_dict['WaterUseProfManuWD'], 
                'WaterUseProfManuWE': column_dict['WaterUseProfManuWE'], 
                'WaterUseProfAutoWD': column_dict['WaterUseProfAutoWD'], 
                'WaterUseProfAutoWE' : column_dict['WaterUseProfAutoWE'], 
                # Population
                "PopDensDay" : '%.3f' % pop_density_day,
                "PopDensNight" : '%.3f' % pop_density_night,
                # Lumps Narp
                "LUMPS_DrRate" : LUMPS_drate,
                "LUMPS_Cover"  : LUMPS_Cover,
                "LUMPS_MaxRes" : LUMPS_MaxRes,
                "NARP_Trans" : NARP_Trans,
                # Water Flow 
                "FlowChange" : flow_change,
                "RunoffToWater" : RunoffToWater,
                "PipeCapacity" : PipeCap,
                "GridConnection1of8" : GridConn1of8,
                "GridConnection2of8" : GridConn2of8,
                "GridConnection3of8" : GridConn3of8,
                "GridConnection4of8" : GridConn4of8,
                "GridConnection5of8" : GridConn5of8,
                "GridConnection6of8" : GridConn6of8,
                "GridConnection7of8" : GridConn7of8,
                "GridConnection8of8" : GridConn8of8,
                "Fraction1of8" : Fraction1of8,
                "Fraction2of8" : Fraction2of8,
                "Fraction3of8" : Fraction3of8,
                "Fraction4of8" : Fraction4of8,
                "Fraction5of8" : Fraction5of8,
                "Fraction6of8" : Fraction6of8,
                "Fraction7of8" : Fraction7of8,
                "Fraction8of8" : Fraction8of8,
                "WithinGridPavedCode" : WhitinGridPav,
                "WithinGridBldgsCode" : WhitinGridBldg,
                "WithinGridEveTrCode" : WhitinGridEve,
                "WithinGridDecTrCode" : WhitinGridDec,
                "WithinGridGrassCode" : WhitinGridGrass,
                "WithinGridUnmanBSoilCode" : WhitinGridUnmanBsoil,
                "WithinGridWaterCode" : WhitinGridWaterCode,

                # ESTM OLD
                "Fr_ESTMClass_Bldgs1": Fr_ESTMClass_Bldgs1,
                "Fr_ESTMClass_Bldgs2": Fr_ESTMClass_Bldgs2,
                "Fr_ESTMClass_Bldgs3": Fr_ESTMClass_Bldgs3,
                "Fr_ESTMClass_Bldgs4": Fr_ESTMClass_Bldgs4,
                "Fr_ESTMClass_Bldgs5": Fr_ESTMClass_Bldgs5,
                "Fr_ESTMClass_Paved1": Fr_ESTMClass_Paved1,
                "Fr_ESTMClass_Paved2": Fr_ESTMClass_Paved2,
                "Fr_ESTMClass_Paved3": Fr_ESTMClass_Paved3,
                "Code_ESTMClass_Bldgs1": Code_ESTMClass_Bldgs1,
                "Code_ESTMClass_Bldgs2": Code_ESTMClass_Bldgs2,
                "Code_ESTMClass_Bldgs3": Code_ESTMClass_Bldgs3,
                "Code_ESTMClass_Bldgs4": Code_ESTMClass_Bldgs4,
                "Code_ESTMClass_Bldgs5": Code_ESTMClass_Bldgs5,
                "Code_ESTMClass_Paved1": Code_ESTMClass_Paved1,
                "Code_ESTMClass_Paved2": Code_ESTMClass_Paved2,
                "Code_ESTMClass_Paved3": Code_ESTMClass_Paved3,  
            }

            for code in SUEWS_param_dict.keys():
                ss_dict[feat_id][code] = str(SUEWS_param_dict[code])

        ss_txt_p = plugin_dir +'/Input/SUEWS_SiteSelect.txt' # TODO Fix to set path wihtin UMEP Toolbox
        save_SiteSelect(ss_dict, save_txt_folder, ss_txt_p)

        init_out = output_dir[0] + '/InitialConditions' + str(file_code) + '_' + str(year) + '.nml'
        self.write_to_init(plugin_dir + '/Input/' + 'InitialConditions.nml', init_out)

        # Response to issue #462. Should change in future versions
        copyfile(plugin_dir + '/Input/' + 'ESTMinput.nml', output_dir[0] + "/" + 'ESTMinput.nml')
        copyfile(plugin_dir + '/Input/' + 'GridLayout.nml', output_dir[0] + "/" + 'GridLayout' + str(file_code) + '.nml') #TODO WHat?

        copyfile(plugin_dir + '/Input/' + 'SUEWS_SPARTACUS.nml', output_dir[0] + "/" + 'SUEWS_SPARTACUS.nml')
        # TODO Fix withinGridWaterDist
        copyfile(plugin_dir + '/Input/' + 'SUEWS_WithinGridWaterDist.txt', output_dir[0] + "/" + 'WithinGridWaterDist.txt')


    def write_to_init(self, initfilein, initfileout):
        LeafCycle = self.leaf_cycle
        SoilMoisture = self.soil_moisture
        moist = int(SoilMoisture * 1.5)
        snowinitially = 0

        nml = f90nml.read(initfilein)

        nml['initialconditions']['soilstorepavedstate'] = moist
        nml['initialconditions']['soilstorebldgsstate'] = moist
        nml['initialconditions']['soilstoreevetrstate'] = moist
        nml['initialconditions']['soilstoredectrstate'] = moist
        nml['initialconditions']['soilstoregrassstate'] = moist
        nml['initialconditions']['soilstorebsoilstate'] = moist

        # Based on London data
        if LeafCycle == 1:  # Winter
            nml['initialconditions']['gdd_1_0'] = 0
            nml['initialconditions']['gdd_2_0'] = -450
            nml['initialconditions']['laiinitialevetr'] = 4
            nml['initialconditions']['laiinitialdectr'] = 1
            nml['initialconditions']['laiinitialgrass'] = 1.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.3
            nml['initialconditions']['porosity0'] = 0.2
        elif LeafCycle == 2:
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.3
        elif LeafCycle == 3:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.6
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 4:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4.5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 5:  # Summer
            nml['initialconditions']['gdd_1_0'] = 300
            nml['initialconditions']['gdd_2_0'] = 0
            nml['initialconditions']['laiinitialevetr'] = 5.1
            nml['initialconditions']['laiinitialdectr'] = 5.5
            nml['initialconditions']['laiinitialgrass'] = 5.9
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.6
        elif LeafCycle == 6:
            nml['initialconditions']['gdd_1_0'] = 225
            nml['initialconditions']['gdd_2_0'] = -150
            nml['initialconditions']['laiinitialevetr'] = 4.9
            nml['initialconditions']['laiinitialdectr'] = 4, 5
            nml['initialconditions']['laiinitialgrass'] = 4.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.8
            nml['initialconditions']['porosity0'] = 0.5
        elif LeafCycle == 7:
            nml['initialconditions']['gdd_1_0'] = 150
            nml['initialconditions']['gdd_2_0'] = -300
            nml['initialconditions']['laiinitialevetr'] = 4.6
            nml['initialconditions']['laiinitialdectr'] = 3.0
            nml['initialconditions']['laiinitialgrass'] = 3.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.5
            nml['initialconditions']['porosity0'] = 0.4
        elif LeafCycle == 8:  # Late Autumn
            nml['initialconditions']['gdd_1_0'] = 50
            nml['initialconditions']['gdd_2_0'] = -400
            nml['initialconditions']['laiinitialevetr'] = 4.2
            nml['initialconditions']['laiinitialdectr'] = 2.0
            nml['initialconditions']['laiinitialgrass'] = 2.6
            nml['initialconditions']['albEveTr0'] = 0.10
            nml['initialconditions']['albDecTr0'] = 0.12
            nml['initialconditions']['albGrass0'] = 0.18
            nml['initialconditions']['decidCap0'] = 0.4
            nml['initialconditions']['porosity0'] = 0.2

        nml['initialconditions']['snowinitially'] = snowinitially

        nml.write(initfileout, force=True)

    def progress_update(self):
        self.steps += 1
        self.dlg.progressBar.setValue(self.steps)


## unused functions
# def hide_show_LCF(self, widget):
    #     if widget.LCF_checkBox.isChecked():
    #         self.LCF_from_file = False
    #         widget.LCF_Frame.show()
    #         widget.pushButtonImportLCF.hide()
    #         widget.textInputLCFData.hide()
    #     else:
    #         self.LCF_from_file = True
    #         widget.LCF_Frame.hide()
    #         widget.pushButtonImportLCF.show()
    #         widget.textInputLCFData.show()

    # def hide_show_IMP(self, widget):
    #     if widget.IMP_checkBox.isChecked():
    #         self.IMP_from_file = False
    #         widget.IMP_Frame.show()
    #         widget.pushButtonImportIMPBuild.hide()
    #         widget.textInputIMPData.hide()
    #     else:
    #         self.IMP_from_file = True
    #         widget.IMP_Frame.hide()
    #         widget.pushButtonImportIMPBuild.show()
    #         widget.textInputIMPData.show()

    # def hide_show_IMPveg(self, widget):
    #     if widget.IMPveg_checkBox.isChecked():
    #         self.IMPveg_from_file = False
    #         widget.IMPveg_Frame.show()
    #         widget.pushButtonImportIMPVeg.hide()
    #         widget.textInputIMPVegData.hide()
    #         widget.checkBox_twovegfiles.hide()
    #         widget.pushButtonImportIMPVeg_eve.hide()
    #         widget.pushButtonImportIMPVeg_dec.hide()
    #         widget.textInputIMPEveData.hide()
    #         widget.textInputIMPDecData.hide()
    #     else:
    #         self.IMPveg_from_file = True
    #         widget.IMPveg_Frame.hide()
    #         widget.pushButtonImportIMPVeg.show()
    #         widget.textInputIMPVegData.show()
    #         widget.checkBox_twovegfiles.show()
    #         widget.pushButtonImportIMPVeg_eve.show()
    #         widget.pushButtonImportIMPVeg_dec.show()
    #         widget.textInputIMPEveData.show()
    #         widget.textInputIMPDecData.show()

    # def grid_layer_changed(self, widget, timezone):

    #     # Try to avoid error when no gridlayer present, or layers added or removed to project
    #     try:
    #         poly = self.layerComboManagerPolygrid.currentLayer()
    #         grid_path = poly.source()
    #         utc = get_utc(grid_path, timezone)
    #         widget.lineEditUTC.setText(str(utc))
    #     except:
    #         pass


